// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_Mods
#include <backend/Mods.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif
#ifndef INCLUDED_tjson_TJSON
#include <tjson/TJSON.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_35_getGlobalMods,"backend.Mods","getGlobalMods",0x282f7527,"backend.Mods.getGlobalMods","backend/Mods.hx",35,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_38_pushGlobalMods,"backend.Mods","pushGlobalMods",0xbafefbd1,"backend.Mods.pushGlobalMods","backend/Mods.hx",38,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_49_getModDirectories,"backend.Mods","getModDirectories",0xf7b0dc9c,"backend.Mods.getModDirectories","backend/Mods.hx",49,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_66_mergeAllTextsNamed,"backend.Mods","mergeAllTextsNamed",0x6b29d5bf,"backend.Mods.mergeAllTextsNamed","backend/Mods.hx",66,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_93_directoriesWithFile,"backend.Mods","directoriesWithFile",0x5a0cfd0a,"backend.Mods.directoriesWithFile","backend/Mods.hx",93,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_126_getPack,"backend.Mods","getPack",0x0de6554c,"backend.Mods.getPack","backend/Mods.hx",126,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_148_parseList,"backend.Mods","parseList",0x838a262e,"backend.Mods.parseList","backend/Mods.hx",148,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_174_updateModList,"backend.Mods","updateModList",0x350647b4,"backend.Mods.updateModList","backend/Mods.hx",174,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_221_loadTopMod,"backend.Mods","loadTopMod",0x40be6756,"backend.Mods.loadTopMod","backend/Mods.hx",221,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_13_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",13,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_14_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",14,0x628d7792)
static const ::String _hx_array_data_a1baaa2b_29[] = {
	HX_("characters",aa,58,ce,55),HX_("custom_events",27,a1,9e,e1),HX_("custom_notetypes",f9,35,37,af),HX_("data",2a,56,63,42),HX_("songs",fe,36,c7,80),HX_("music",a5,d0,5a,10),HX_("sounds",c4,a8,2e,32),HX_("shaders",ae,81,86,5f),HX_("videos",98,d7,95,e5),HX_("images",b8,50,92,fe),HX_("stages",f5,fb,f1,05),HX_("weeks",ff,95,be,c7),HX_("fonts",c4,b7,91,04),HX_("scripts",08,fc,e3,2c),HX_("achievements",24,a1,6b,86),
};
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_32_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",32,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_147_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",147,0x628d7792)
namespace backend{

void Mods_obj::__construct() { }

Dynamic Mods_obj::__CreateEmpty() { return new Mods_obj; }

void *Mods_obj::_hx_vtable = 0;

Dynamic Mods_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Mods_obj > _hx_result = new Mods_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Mods_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x51ebbac1;
}

::String Mods_obj::currentModDirectory;

::Array< ::String > Mods_obj::ignoreModFolders;

::Array< ::String > Mods_obj::globalMods;

::Array< ::String > Mods_obj::getGlobalMods(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_35_getGlobalMods)
HXDLIN(  35)		return ::backend::Mods_obj::globalMods;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,getGlobalMods,return )

::Array< ::String > Mods_obj::pushGlobalMods(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_38_pushGlobalMods)
HXLINE(  39)		::backend::Mods_obj::globalMods = ::Array_obj< ::String >::__new(0);
HXLINE(  40)		{
HXLINE(  40)			int _g = 0;
HXDLIN(  40)			if (!(::backend::Mods_obj::updatedOnState)) {
HXLINE(  40)				::backend::Mods_obj::updateModList();
            			}
HXDLIN(  40)			::Array< ::String > list_enabled = ::Array_obj< ::String >::__new(0);
HXDLIN(  40)			::Array< ::String > list_disabled = ::Array_obj< ::String >::__new(0);
HXDLIN(  40)			::Array< ::String > list_all = ::Array_obj< ::String >::__new(0);
HXDLIN(  40)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  40)				int _g1 = 0;
HXDLIN(  40)				::String path = HX_("modsList.txt",f1,ca,08,ac);
HXDLIN(  40)				::String daList = null();
HXDLIN(  40)				::Array< ::String > formatted = path.split(HX_(":",3a,00,00,00));
HXLINE(  23)				path = formatted->__get((formatted->length - 1));
HXLINE(  40)				if (::sys::FileSystem_obj::exists(path)) {
HXLINE(  24)					daList = ::sys::io::File_obj::getContent(path);
            				}
HXLINE(  40)				::Array< ::String > _g2;
HXDLIN(  40)				if (::hx::IsNotNull( daList )) {
HXLINE(  40)					::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXLINE(  45)					daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXLINE(  40)					{
HXLINE(  40)						int _g3 = 0;
HXDLIN(  40)						int _g4 = daList1->length;
HXDLIN(  40)						while((_g3 < _g4)){
HXLINE(  40)							_g3 = (_g3 + 1);
HXDLIN(  40)							int i = (_g3 - 1);
HXDLIN(  40)							daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            						}
            					}
HXDLIN(  40)					_g2 = daList1;
            				}
            				else {
HXLINE(  40)					_g2 = ::Array_obj< ::String >::__new(0);
            				}
HXDLIN(  40)				while((_g1 < _g2->length)){
HXLINE(  40)					::String mod = _g2->__get(_g1);
HXDLIN(  40)					_g1 = (_g1 + 1);
HXDLIN(  40)					if ((::StringTools_obj::trim(mod).length < 1)) {
HXLINE(  40)						continue;
            					}
HXDLIN(  40)					::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXDLIN(  40)					list_all->push(dat->__get(0));
HXDLIN(  40)					if ((dat->__get(1) == HX_("1",31,00,00,00))) {
HXLINE(  40)						list_enabled->push(dat->__get(0));
            					}
            					else {
HXLINE(  40)						list_disabled->push(dat->__get(0));
            					}
            				}
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g5 = _hx_e;
HXLINE( 166)					 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g5);
HXLINE(  40)					::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),167,HX_("backend.Mods",2b,aa,ba,a1),HX_("parseList",31,6e,59,cf)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXDLIN(  40)			::Array< ::String > _g6 = list_enabled;
HXDLIN(  40)			while((_g < _g6->length)){
HXLINE(  40)				::String mod1 = _g6->__get(_g);
HXDLIN(  40)				_g = (_g + 1);
HXLINE(  42)				 ::Dynamic pack = ::backend::Mods_obj::getPack(mod1);
HXLINE(  43)				bool _hx_tmp;
HXDLIN(  43)				if (::hx::IsNotNull( pack )) {
HXLINE(  43)					_hx_tmp = ( (bool)(pack->__Field(HX_("runsGlobally",98,2d,b5,06),::hx::paccDynamic)) );
            				}
            				else {
HXLINE(  43)					_hx_tmp = false;
            				}
HXDLIN(  43)				if (_hx_tmp) {
HXLINE(  43)					::backend::Mods_obj::globalMods->push(mod1);
            				}
            			}
            		}
HXLINE(  45)		return ::backend::Mods_obj::globalMods;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,pushGlobalMods,return )

::Array< ::String > Mods_obj::getModDirectories(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_49_getModDirectories)
HXLINE(  50)		::Array< ::String > list = ::Array_obj< ::String >::__new(0);
HXLINE(  52)		::String modsFolder = HX_("mods/",9e,2f,58,0c);
HXLINE(  53)		if (::sys::FileSystem_obj::exists(modsFolder)) {
HXLINE(  54)			int _g = 0;
HXDLIN(  54)			::Array< ::String > _g1 = ::sys::FileSystem_obj::readDirectory(modsFolder);
HXDLIN(  54)			while((_g < _g1->length)){
HXLINE(  54)				::String folder = _g1->__get(_g);
HXDLIN(  54)				_g = (_g + 1);
HXLINE(  56)				::String path = ::haxe::io::Path_obj::join(::Array_obj< ::String >::__new(2)->init(0,modsFolder)->init(1,folder));
HXLINE(  57)				bool _hx_tmp;
HXDLIN(  57)				bool _hx_tmp1;
HXDLIN(  57)				if (::sys::FileSystem_obj::isDirectory(path)) {
HXLINE(  57)					::Array< ::String > _hx_tmp2 = ::backend::Mods_obj::ignoreModFolders;
HXDLIN(  57)					_hx_tmp1 = !(_hx_tmp2->contains(folder.toLowerCase()));
            				}
            				else {
HXLINE(  57)					_hx_tmp1 = false;
            				}
HXDLIN(  57)				if (_hx_tmp1) {
HXLINE(  57)					_hx_tmp = !(list->contains(folder));
            				}
            				else {
HXLINE(  57)					_hx_tmp = false;
            				}
HXDLIN(  57)				if (_hx_tmp) {
HXLINE(  58)					list->push(folder);
            				}
            			}
            		}
HXLINE(  62)		return list;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,getModDirectories,return )

::Array< ::String > Mods_obj::mergeAllTextsNamed(::String path,::String defaultDirectory,::hx::Null< bool >  __o_allowDuplicates){
            		bool allowDuplicates = __o_allowDuplicates.Default(false);
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_66_mergeAllTextsNamed)
HXLINE(  67)		if (::hx::IsNull( defaultDirectory )) {
HXLINE(  67)			defaultDirectory = HX_("assets/shared/",1e,69,1e,47);
            		}
HXLINE(  68)		defaultDirectory = ::StringTools_obj::trim(defaultDirectory);
HXLINE(  69)		if (!(::StringTools_obj::endsWith(defaultDirectory,HX_("/",2f,00,00,00)))) {
HXLINE(  69)			defaultDirectory = (defaultDirectory + HX_("/",2f,00,00,00));
            		}
HXLINE(  70)		if (!(::StringTools_obj::startsWith(defaultDirectory,HX_("assets/",4c,2a,dc,36)))) {
HXLINE(  70)			defaultDirectory = (HX_("assets/",4c,2a,dc,36) + defaultDirectory);
            		}
HXLINE(  72)		::Array< ::String > mergedList = ::Array_obj< ::String >::__new(0);
HXLINE(  73)		::Array< ::String > foldersToCheck = ::Array_obj< ::String >::__new(0);
HXDLIN(  73)		if (::sys::FileSystem_obj::exists((defaultDirectory + path))) {
HXLINE(  73)			foldersToCheck->push((defaultDirectory + path));
            		}
HXDLIN(  73)		{
HXLINE(  73)			{
HXLINE(  73)				int _g = 0;
HXDLIN(  73)				::Array< ::String > _g1 = ::backend::Mods_obj::globalMods;
HXDLIN(  73)				while((_g < _g1->length)){
HXLINE(  73)					::String mod = _g1->__get(_g);
HXDLIN(  73)					_g = (_g + 1);
HXDLIN(  73)					::String key = ((mod + HX_("/",2f,00,00,00)) + path);
HXDLIN(  73)					if (::hx::IsNull( key )) {
HXLINE(  73)						key = HX_("",00,00,00,00);
            					}
HXDLIN(  73)					::String folder = (HX_("mods/",9e,2f,58,0c) + key);
HXDLIN(  73)					bool _hx_tmp;
HXDLIN(  73)					if (::sys::FileSystem_obj::exists(folder)) {
HXLINE(  73)						_hx_tmp = !(foldersToCheck->contains(folder));
            					}
            					else {
HXLINE(  73)						_hx_tmp = false;
            					}
HXDLIN(  73)					if (_hx_tmp) {
HXLINE(  73)						foldersToCheck->push(folder);
            					}
            				}
            			}
HXDLIN(  73)			::String key1 = path;
HXDLIN(  73)			if (::hx::IsNull( key1 )) {
HXLINE(  73)				key1 = HX_("",00,00,00,00);
            			}
HXDLIN(  73)			::String folder1 = (HX_("mods/",9e,2f,58,0c) + key1);
HXDLIN(  73)			bool _hx_tmp1;
HXDLIN(  73)			if (::sys::FileSystem_obj::exists(folder1)) {
HXLINE(  73)				_hx_tmp1 = !(foldersToCheck->contains(folder1));
            			}
            			else {
HXLINE(  73)				_hx_tmp1 = false;
            			}
HXDLIN(  73)			if (_hx_tmp1) {
HXLINE(  73)				::String key2 = path;
HXDLIN(  73)				if (::hx::IsNull( key2 )) {
HXLINE(  73)					key2 = HX_("",00,00,00,00);
            				}
HXDLIN(  73)				foldersToCheck->push((HX_("mods/",9e,2f,58,0c) + key2));
            			}
HXDLIN(  73)			bool _hx_tmp2;
HXDLIN(  73)			if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE(  73)				_hx_tmp2 = (::backend::Mods_obj::currentModDirectory.length > 0);
            			}
            			else {
HXLINE(  73)				_hx_tmp2 = false;
            			}
HXDLIN(  73)			if (_hx_tmp2) {
HXLINE(  73)				::String key3 = ((::backend::Mods_obj::currentModDirectory + HX_("/",2f,00,00,00)) + path);
HXDLIN(  73)				if (::hx::IsNull( key3 )) {
HXLINE(  73)					key3 = HX_("",00,00,00,00);
            				}
HXDLIN(  73)				::String folder2 = (HX_("mods/",9e,2f,58,0c) + key3);
HXDLIN(  73)				bool _hx_tmp3;
HXDLIN(  73)				if (::sys::FileSystem_obj::exists(folder2)) {
HXLINE(  73)					_hx_tmp3 = !(foldersToCheck->contains(folder2));
            				}
            				else {
HXLINE(  73)					_hx_tmp3 = false;
            				}
HXDLIN(  73)				if (_hx_tmp3) {
HXLINE(  73)					foldersToCheck->push(folder2);
            				}
            			}
            		}
HXDLIN(  73)		::Array< ::String > paths = foldersToCheck;
HXLINE(  75)		::String defaultPath = (defaultDirectory + path);
HXLINE(  76)		if (paths->contains(defaultPath)) {
HXLINE(  78)			paths->remove(defaultPath);
HXLINE(  79)			paths->insert(0,defaultPath);
            		}
HXLINE(  82)		{
HXLINE(  82)			int _g2 = 0;
HXDLIN(  82)			while((_g2 < paths->length)){
HXLINE(  82)				::String file = paths->__get(_g2);
HXDLIN(  82)				_g2 = (_g2 + 1);
HXLINE(  84)				::String path1 = file;
HXDLIN(  84)				::String daList = null();
HXDLIN(  84)				::Array< ::String > formatted = path1.split(HX_(":",3a,00,00,00));
HXDLIN(  84)				path1 = formatted->__get((formatted->length - 1));
HXDLIN(  84)				if (::sys::FileSystem_obj::exists(path1)) {
HXLINE(  84)					daList = ::sys::io::File_obj::getContent(path1);
            				}
HXDLIN(  84)				::Array< ::String > list;
HXDLIN(  84)				if (::hx::IsNotNull( daList )) {
HXLINE(  84)					::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN(  84)					daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN(  84)					{
HXLINE(  84)						int _g3 = 0;
HXDLIN(  84)						int _g4 = daList1->length;
HXDLIN(  84)						while((_g3 < _g4)){
HXLINE(  84)							_g3 = (_g3 + 1);
HXDLIN(  84)							int i = (_g3 - 1);
HXDLIN(  84)							daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            						}
            					}
HXDLIN(  84)					list = daList1;
            				}
            				else {
HXLINE(  84)					list = ::Array_obj< ::String >::__new(0);
            				}
HXLINE(  85)				{
HXLINE(  85)					int _g5 = 0;
HXDLIN(  85)					while((_g5 < list->length)){
HXLINE(  85)						::String value = list->__get(_g5);
HXDLIN(  85)						_g5 = (_g5 + 1);
HXLINE(  86)						bool _hx_tmp4;
HXDLIN(  86)						bool _hx_tmp5;
HXDLIN(  86)						if (!(allowDuplicates)) {
HXLINE(  86)							_hx_tmp5 = !(mergedList->contains(value));
            						}
            						else {
HXLINE(  86)							_hx_tmp5 = true;
            						}
HXDLIN(  86)						if (_hx_tmp5) {
HXLINE(  86)							_hx_tmp4 = (value.length > 0);
            						}
            						else {
HXLINE(  86)							_hx_tmp4 = false;
            						}
HXDLIN(  86)						if (_hx_tmp4) {
HXLINE(  87)							mergedList->push(value);
            						}
            					}
            				}
            			}
            		}
HXLINE(  89)		return mergedList;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Mods_obj,mergeAllTextsNamed,return )

::Array< ::String > Mods_obj::directoriesWithFile(::String path,::String fileToFind,::hx::Null< bool >  __o_mods){
            		bool mods = __o_mods.Default(true);
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_93_directoriesWithFile)
HXLINE(  94)		::Array< ::String > foldersToCheck = ::Array_obj< ::String >::__new(0);
HXLINE(  96)		if (::sys::FileSystem_obj::exists((path + fileToFind))) {
HXLINE(  98)			foldersToCheck->push((path + fileToFind));
            		}
HXLINE( 101)		if (mods) {
HXLINE( 104)			{
HXLINE( 104)				int _g = 0;
HXDLIN( 104)				::Array< ::String > _g1 = ::backend::Mods_obj::globalMods;
HXDLIN( 104)				while((_g < _g1->length)){
HXLINE( 104)					::String mod = _g1->__get(_g);
HXDLIN( 104)					_g = (_g + 1);
HXLINE( 106)					::String key = ((mod + HX_("/",2f,00,00,00)) + fileToFind);
HXDLIN( 106)					if (::hx::IsNull( key )) {
HXLINE( 106)						key = HX_("",00,00,00,00);
            					}
HXDLIN( 106)					::String folder = (HX_("mods/",9e,2f,58,0c) + key);
HXLINE( 107)					bool _hx_tmp;
HXDLIN( 107)					if (::sys::FileSystem_obj::exists(folder)) {
HXLINE( 107)						_hx_tmp = !(foldersToCheck->contains(folder));
            					}
            					else {
HXLINE( 107)						_hx_tmp = false;
            					}
HXDLIN( 107)					if (_hx_tmp) {
HXLINE( 107)						foldersToCheck->push(folder);
            					}
            				}
            			}
HXLINE( 111)			::String key1 = fileToFind;
HXDLIN( 111)			if (::hx::IsNull( key1 )) {
HXLINE( 111)				key1 = HX_("",00,00,00,00);
            			}
HXDLIN( 111)			::String folder1 = (HX_("mods/",9e,2f,58,0c) + key1);
HXLINE( 112)			bool _hx_tmp1;
HXDLIN( 112)			if (::sys::FileSystem_obj::exists(folder1)) {
HXLINE( 112)				_hx_tmp1 = !(foldersToCheck->contains(folder1));
            			}
            			else {
HXLINE( 112)				_hx_tmp1 = false;
            			}
HXDLIN( 112)			if (_hx_tmp1) {
HXLINE( 112)				::String key2 = fileToFind;
HXDLIN( 112)				if (::hx::IsNull( key2 )) {
HXLINE( 112)					key2 = HX_("",00,00,00,00);
            				}
HXDLIN( 112)				foldersToCheck->push((HX_("mods/",9e,2f,58,0c) + key2));
            			}
HXLINE( 115)			bool _hx_tmp2;
HXDLIN( 115)			if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE( 115)				_hx_tmp2 = (::backend::Mods_obj::currentModDirectory.length > 0);
            			}
            			else {
HXLINE( 115)				_hx_tmp2 = false;
            			}
HXDLIN( 115)			if (_hx_tmp2) {
HXLINE( 117)				::String key3 = ((::backend::Mods_obj::currentModDirectory + HX_("/",2f,00,00,00)) + fileToFind);
HXDLIN( 117)				if (::hx::IsNull( key3 )) {
HXLINE( 117)					key3 = HX_("",00,00,00,00);
            				}
HXDLIN( 117)				::String folder2 = (HX_("mods/",9e,2f,58,0c) + key3);
HXLINE( 118)				bool _hx_tmp3;
HXDLIN( 118)				if (::sys::FileSystem_obj::exists(folder2)) {
HXLINE( 118)					_hx_tmp3 = !(foldersToCheck->contains(folder2));
            				}
            				else {
HXLINE( 118)					_hx_tmp3 = false;
            				}
HXDLIN( 118)				if (_hx_tmp3) {
HXLINE( 118)					foldersToCheck->push(folder2);
            				}
            			}
            		}
HXLINE( 122)		return foldersToCheck;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Mods_obj,directoriesWithFile,return )

 ::Dynamic Mods_obj::getPack(::String folder){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_126_getPack)
HXLINE( 128)		if (::hx::IsNull( folder )) {
HXLINE( 128)			folder = ::backend::Mods_obj::currentModDirectory;
            		}
HXLINE( 130)		::String key = (folder + HX_("/pack.json",ce,a9,3a,e3));
HXDLIN( 130)		if (::hx::IsNull( key )) {
HXLINE( 130)			key = HX_("",00,00,00,00);
            		}
HXDLIN( 130)		::String path = (HX_("mods/",9e,2f,58,0c) + key);
HXLINE( 131)		if (::sys::FileSystem_obj::exists(path)) {
HXLINE( 132)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 134)				::String rawJson = ::sys::io::File_obj::getContent(path);
HXLINE( 138)				bool _hx_tmp;
HXDLIN( 138)				if (::hx::IsNotNull( rawJson )) {
HXLINE( 138)					_hx_tmp = (rawJson.length > 0);
            				}
            				else {
HXLINE( 138)					_hx_tmp = false;
            				}
HXDLIN( 138)				if (_hx_tmp) {
HXLINE( 138)					return ::tjson::TJSON_obj::parse(rawJson,null(),null());
            				}
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE( 139)					{
HXLINE( 139)						null();
            					}
HXDLIN( 139)					 ::Dynamic e = _g;
HXLINE( 140)					::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),140,HX_("backend.Mods",2b,aa,ba,a1),HX_("getPack",8f,86,d4,1c)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
HXLINE( 144)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mods_obj,getPack,return )

bool Mods_obj::updatedOnState;

 ::Dynamic Mods_obj::parseList(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_148_parseList)
HXLINE( 149)		if (!(::backend::Mods_obj::updatedOnState)) {
HXLINE( 149)			::backend::Mods_obj::updateModList();
            		}
HXLINE( 150)		 ::Dynamic list =  ::Dynamic(::hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("all",21,f9,49,00),::Array_obj< ::String >::__new(0))
            			->setFixed(1,HX_("disabled",7c,41,04,7c),::Array_obj< ::String >::__new(0))
            			->setFixed(2,HX_("enabled",81,04,31,7e),::Array_obj< ::String >::__new(0)));
HXLINE( 153)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 154)			int _g = 0;
HXDLIN( 154)			::String path = HX_("modsList.txt",f1,ca,08,ac);
HXDLIN( 154)			::String daList = null();
HXDLIN( 154)			::Array< ::String > formatted = path.split(HX_(":",3a,00,00,00));
HXDLIN( 154)			path = formatted->__get((formatted->length - 1));
HXDLIN( 154)			if (::sys::FileSystem_obj::exists(path)) {
HXLINE( 154)				daList = ::sys::io::File_obj::getContent(path);
            			}
HXDLIN( 154)			::Array< ::String > _g1;
HXDLIN( 154)			if (::hx::IsNotNull( daList )) {
HXLINE( 154)				::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN( 154)				daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN( 154)				{
HXLINE( 154)					int _g2 = 0;
HXDLIN( 154)					int _g3 = daList1->length;
HXDLIN( 154)					while((_g2 < _g3)){
HXLINE( 154)						_g2 = (_g2 + 1);
HXDLIN( 154)						int i = (_g2 - 1);
HXDLIN( 154)						daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            					}
            				}
HXDLIN( 154)				_g1 = daList1;
            			}
            			else {
HXLINE( 154)				_g1 = ::Array_obj< ::String >::__new(0);
            			}
HXDLIN( 154)			while((_g < _g1->length)){
HXLINE( 154)				::String mod = _g1->__get(_g);
HXDLIN( 154)				_g = (_g + 1);
HXLINE( 157)				if ((::StringTools_obj::trim(mod).length < 1)) {
HXLINE( 157)					continue;
            				}
HXLINE( 159)				::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXLINE( 160)				( (::Array< ::String >)(list->__Field(HX_("all",21,f9,49,00),::hx::paccDynamic)) )->push(dat->__get(0));
HXLINE( 161)				if ((dat->__get(1) == HX_("1",31,00,00,00))) {
HXLINE( 162)					( (::Array< ::String >)(list->__Field(HX_("enabled",81,04,31,7e),::hx::paccDynamic)) )->push(dat->__get(0));
            				}
            				else {
HXLINE( 164)					( (::Array< ::String >)(list->__Field(HX_("disabled",7c,41,04,7c),::hx::paccDynamic)) )->push(dat->__get(0));
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g4 = _hx_e;
HXLINE( 166)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g4);
HXLINE( 167)				::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),167,HX_("backend.Mods",2b,aa,ba,a1),HX_("parseList",31,6e,59,cf)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 170)		return list;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,parseList,return )

void Mods_obj::updateModList(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_174_updateModList)
HXLINE( 177)		::Array< ::Dynamic> list = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 178)		::Array< ::String > added = ::Array_obj< ::String >::__new(0);
HXLINE( 179)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 180)			int _g = 0;
HXDLIN( 180)			::String path = HX_("modsList.txt",f1,ca,08,ac);
HXDLIN( 180)			::String daList = null();
HXDLIN( 180)			::Array< ::String > formatted = path.split(HX_(":",3a,00,00,00));
HXDLIN( 180)			path = formatted->__get((formatted->length - 1));
HXDLIN( 180)			if (::sys::FileSystem_obj::exists(path)) {
HXLINE( 180)				daList = ::sys::io::File_obj::getContent(path);
            			}
HXDLIN( 180)			::Array< ::String > _g1;
HXDLIN( 180)			if (::hx::IsNotNull( daList )) {
HXLINE( 180)				::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN( 180)				daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN( 180)				{
HXLINE( 180)					int _g2 = 0;
HXDLIN( 180)					int _g3 = daList1->length;
HXDLIN( 180)					while((_g2 < _g3)){
HXLINE( 180)						_g2 = (_g2 + 1);
HXDLIN( 180)						int i = (_g2 - 1);
HXDLIN( 180)						daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            					}
            				}
HXDLIN( 180)				_g1 = daList1;
            			}
            			else {
HXLINE( 180)				_g1 = ::Array_obj< ::String >::__new(0);
            			}
HXDLIN( 180)			while((_g < _g1->length)){
HXLINE( 180)				::String mod = _g1->__get(_g);
HXDLIN( 180)				_g = (_g + 1);
HXLINE( 182)				::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXLINE( 183)				::String folder = dat->__get(0);
HXLINE( 184)				bool _hx_tmp;
HXDLIN( 184)				bool _hx_tmp1;
HXDLIN( 184)				bool _hx_tmp2;
HXDLIN( 184)				if ((::StringTools_obj::trim(folder).length > 0)) {
HXLINE( 184)					::String key = folder;
HXDLIN( 184)					if (::hx::IsNull( key )) {
HXLINE( 184)						key = HX_("",00,00,00,00);
            					}
HXDLIN( 184)					_hx_tmp2 = ::sys::FileSystem_obj::exists((HX_("mods/",9e,2f,58,0c) + key));
            				}
            				else {
HXLINE( 184)					_hx_tmp2 = false;
            				}
HXDLIN( 184)				if (_hx_tmp2) {
HXLINE( 184)					::String key1 = folder;
HXDLIN( 184)					if (::hx::IsNull( key1 )) {
HXLINE( 184)						key1 = HX_("",00,00,00,00);
            					}
HXDLIN( 184)					_hx_tmp1 = ::sys::FileSystem_obj::isDirectory((HX_("mods/",9e,2f,58,0c) + key1));
            				}
            				else {
HXLINE( 184)					_hx_tmp1 = false;
            				}
HXDLIN( 184)				if (_hx_tmp1) {
HXLINE( 184)					_hx_tmp = !(added->contains(folder));
            				}
            				else {
HXLINE( 184)					_hx_tmp = false;
            				}
HXDLIN( 184)				if (_hx_tmp) {
HXLINE( 186)					added->push(folder);
HXLINE( 187)					list->push(::cpp::VirtualArray_obj::__new(2)->init(0,folder)->init(1,(dat->__get(1) == HX_("1",31,00,00,00))));
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g4 = _hx_e;
HXLINE( 190)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g4);
HXLINE( 191)				::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),191,HX_("backend.Mods",2b,aa,ba,a1),HX_("updateModList",37,4d,4d,a8)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 195)		{
HXLINE( 195)			int _g5 = 0;
HXDLIN( 195)			::Array< ::String > list1 = ::Array_obj< ::String >::__new(0);
HXDLIN( 195)			::String modsFolder = HX_("mods/",9e,2f,58,0c);
HXDLIN( 195)			if (::sys::FileSystem_obj::exists(modsFolder)) {
HXLINE( 195)				int _g6 = 0;
HXDLIN( 195)				::Array< ::String > _g7 = ::sys::FileSystem_obj::readDirectory(modsFolder);
HXDLIN( 195)				while((_g6 < _g7->length)){
HXLINE( 195)					::String folder1 = _g7->__get(_g6);
HXDLIN( 195)					_g6 = (_g6 + 1);
HXDLIN( 195)					::String path1 = ::haxe::io::Path_obj::join(::Array_obj< ::String >::__new(2)->init(0,modsFolder)->init(1,folder1));
HXDLIN( 195)					bool _hx_tmp3;
HXDLIN( 195)					bool _hx_tmp4;
HXDLIN( 195)					if (::sys::FileSystem_obj::isDirectory(path1)) {
HXLINE( 195)						::Array< ::String > _hx_tmp5 = ::backend::Mods_obj::ignoreModFolders;
HXDLIN( 195)						_hx_tmp4 = !(_hx_tmp5->contains(folder1.toLowerCase()));
            					}
            					else {
HXLINE( 195)						_hx_tmp4 = false;
            					}
HXDLIN( 195)					if (_hx_tmp4) {
HXLINE( 195)						_hx_tmp3 = !(list1->contains(folder1));
            					}
            					else {
HXLINE( 195)						_hx_tmp3 = false;
            					}
HXDLIN( 195)					if (_hx_tmp3) {
HXLINE( 195)						list1->push(folder1);
            					}
            				}
            			}
HXDLIN( 195)			::Array< ::String > _g8 = list1;
HXDLIN( 195)			while((_g5 < _g8->length)){
HXLINE( 195)				::String folder2 = _g8->__get(_g5);
HXDLIN( 195)				_g5 = (_g5 + 1);
HXLINE( 197)				bool _hx_tmp6;
HXDLIN( 197)				bool _hx_tmp7;
HXDLIN( 197)				bool _hx_tmp8;
HXDLIN( 197)				bool _hx_tmp9;
HXDLIN( 197)				if ((::StringTools_obj::trim(folder2).length > 0)) {
HXLINE( 197)					::String key2 = folder2;
HXDLIN( 197)					if (::hx::IsNull( key2 )) {
HXLINE( 197)						key2 = HX_("",00,00,00,00);
            					}
HXDLIN( 197)					_hx_tmp9 = ::sys::FileSystem_obj::exists((HX_("mods/",9e,2f,58,0c) + key2));
            				}
            				else {
HXLINE( 197)					_hx_tmp9 = false;
            				}
HXDLIN( 197)				if (_hx_tmp9) {
HXLINE( 197)					::String key3 = folder2;
HXDLIN( 197)					if (::hx::IsNull( key3 )) {
HXLINE( 197)						key3 = HX_("",00,00,00,00);
            					}
HXDLIN( 197)					_hx_tmp8 = ::sys::FileSystem_obj::isDirectory((HX_("mods/",9e,2f,58,0c) + key3));
            				}
            				else {
HXLINE( 197)					_hx_tmp8 = false;
            				}
HXDLIN( 197)				if (_hx_tmp8) {
HXLINE( 198)					::Array< ::String > _hx_tmp10 = ::backend::Mods_obj::ignoreModFolders;
HXLINE( 197)					_hx_tmp7 = !(_hx_tmp10->contains(folder2.toLowerCase()));
            				}
            				else {
HXLINE( 197)					_hx_tmp7 = false;
            				}
HXDLIN( 197)				if (_hx_tmp7) {
HXLINE( 197)					_hx_tmp6 = !(added->contains(folder2));
            				}
            				else {
HXLINE( 197)					_hx_tmp6 = false;
            				}
HXDLIN( 197)				if (_hx_tmp6) {
HXLINE( 200)					added->push(folder2);
HXLINE( 201)					list->push(::cpp::VirtualArray_obj::__new(2)->init(0,folder2)->init(1,true));
            				}
            			}
            		}
HXLINE( 207)		::String fileStr = HX_("",00,00,00,00);
HXLINE( 208)		{
HXLINE( 208)			int _g9 = 0;
HXDLIN( 208)			while((_g9 < list->length)){
HXLINE( 208)				::cpp::VirtualArray values = ::cpp::VirtualArray( list->__get(_g9));
HXDLIN( 208)				_g9 = (_g9 + 1);
HXLINE( 210)				if ((fileStr.length > 0)) {
HXLINE( 210)					fileStr = (fileStr + HX_("\n",0a,00,00,00));
            				}
HXLINE( 211)				::String fileStr1 = (::Std_obj::string(values->__get(0)) + HX_("|",7c,00,00,00));
HXDLIN( 211)				::String fileStr2;
HXDLIN( 211)				if (( (bool)(values->__get(1)) )) {
HXLINE( 211)					fileStr2 = HX_("1",31,00,00,00);
            				}
            				else {
HXLINE( 211)					fileStr2 = HX_("0",30,00,00,00);
            				}
HXDLIN( 211)				fileStr = (fileStr + (fileStr1 + fileStr2));
            			}
            		}
HXLINE( 214)		::sys::io::File_obj::saveContent(HX_("modsList.txt",f1,ca,08,ac),fileStr);
HXLINE( 215)		::backend::Mods_obj::updatedOnState = true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,updateModList,(void))

void Mods_obj::loadTopMod(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_221_loadTopMod)
HXLINE( 222)		::backend::Mods_obj::currentModDirectory = HX_("",00,00,00,00);
HXLINE( 225)		if (!(::backend::Mods_obj::updatedOnState)) {
HXLINE( 225)			::backend::Mods_obj::updateModList();
            		}
HXDLIN( 225)		::Array< ::String > list_enabled = ::Array_obj< ::String >::__new(0);
HXDLIN( 225)		::Array< ::String > list_disabled = ::Array_obj< ::String >::__new(0);
HXDLIN( 225)		::Array< ::String > list_all = ::Array_obj< ::String >::__new(0);
HXDLIN( 225)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 225)			int _g = 0;
HXDLIN( 225)			::String path = HX_("modsList.txt",f1,ca,08,ac);
HXDLIN( 225)			::String daList = null();
HXDLIN( 225)			::Array< ::String > formatted = path.split(HX_(":",3a,00,00,00));
HXLINE(  23)			path = formatted->__get((formatted->length - 1));
HXLINE( 225)			if (::sys::FileSystem_obj::exists(path)) {
HXLINE(  24)				daList = ::sys::io::File_obj::getContent(path);
            			}
HXLINE( 225)			::Array< ::String > _g1;
HXDLIN( 225)			if (::hx::IsNotNull( daList )) {
HXLINE( 225)				::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXLINE(  45)				daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXLINE( 225)				{
HXLINE( 225)					int _g2 = 0;
HXDLIN( 225)					int _g3 = daList1->length;
HXDLIN( 225)					while((_g2 < _g3)){
HXLINE( 225)						_g2 = (_g2 + 1);
HXDLIN( 225)						int i = (_g2 - 1);
HXDLIN( 225)						daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            					}
            				}
HXDLIN( 225)				_g1 = daList1;
            			}
            			else {
HXLINE( 225)				_g1 = ::Array_obj< ::String >::__new(0);
            			}
HXDLIN( 225)			while((_g < _g1->length)){
HXLINE( 225)				::String mod = _g1->__get(_g);
HXDLIN( 225)				_g = (_g + 1);
HXDLIN( 225)				if ((::StringTools_obj::trim(mod).length < 1)) {
HXLINE( 225)					continue;
            				}
HXDLIN( 225)				::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXDLIN( 225)				list_all->push(dat->__get(0));
HXDLIN( 225)				if ((dat->__get(1) == HX_("1",31,00,00,00))) {
HXLINE( 225)					list_enabled->push(dat->__get(0));
            				}
            				else {
HXLINE( 225)					list_disabled->push(dat->__get(0));
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g4 = _hx_e;
HXLINE( 166)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g4);
HXLINE( 225)				::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),167,HX_("backend.Mods",2b,aa,ba,a1),HX_("parseList",31,6e,59,cf)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXDLIN( 225)		::Array< ::String > list = list_enabled;
HXLINE( 226)		bool _hx_tmp;
HXDLIN( 226)		if (::hx::IsNotNull( list )) {
HXLINE( 226)			_hx_tmp = ::hx::IsNotNull( list->__get(0) );
            		}
            		else {
HXLINE( 226)			_hx_tmp = false;
            		}
HXDLIN( 226)		if (_hx_tmp) {
HXLINE( 227)			::backend::Mods_obj::currentModDirectory = list->__get(0);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,loadTopMod,(void))


Mods_obj::Mods_obj()
{
}

bool Mods_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"getPack") ) { outValue = getPack_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"parseList") ) { outValue = parseList_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"globalMods") ) { outValue = ( globalMods ); return true; }
		if (HX_FIELD_EQ(inName,"loadTopMod") ) { outValue = loadTopMod_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getGlobalMods") ) { outValue = getGlobalMods_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"updateModList") ) { outValue = updateModList_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"pushGlobalMods") ) { outValue = pushGlobalMods_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"updatedOnState") ) { outValue = ( updatedOnState ); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"ignoreModFolders") ) { outValue = ( ignoreModFolders ); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getModDirectories") ) { outValue = getModDirectories_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"mergeAllTextsNamed") ) { outValue = mergeAllTextsNamed_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"currentModDirectory") ) { outValue = ( currentModDirectory ); return true; }
		if (HX_FIELD_EQ(inName,"directoriesWithFile") ) { outValue = directoriesWithFile_dyn(); return true; }
	}
	return false;
}

bool Mods_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"globalMods") ) { globalMods=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updatedOnState") ) { updatedOnState=ioValue.Cast< bool >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"ignoreModFolders") ) { ignoreModFolders=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"currentModDirectory") ) { currentModDirectory=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Mods_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Mods_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &Mods_obj::currentModDirectory,HX_("currentModDirectory",24,ad,ec,de)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &Mods_obj::ignoreModFolders,HX_("ignoreModFolders",15,37,dd,7e)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &Mods_obj::globalMods,HX_("globalMods",74,1e,04,3f)},
	{::hx::fsBool,(void *) &Mods_obj::updatedOnState,HX_("updatedOnState",77,07,c7,9a)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Mods_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Mods_obj::currentModDirectory,"currentModDirectory");
	HX_MARK_MEMBER_NAME(Mods_obj::ignoreModFolders,"ignoreModFolders");
	HX_MARK_MEMBER_NAME(Mods_obj::globalMods,"globalMods");
	HX_MARK_MEMBER_NAME(Mods_obj::updatedOnState,"updatedOnState");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Mods_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Mods_obj::currentModDirectory,"currentModDirectory");
	HX_VISIT_MEMBER_NAME(Mods_obj::ignoreModFolders,"ignoreModFolders");
	HX_VISIT_MEMBER_NAME(Mods_obj::globalMods,"globalMods");
	HX_VISIT_MEMBER_NAME(Mods_obj::updatedOnState,"updatedOnState");
};

#endif

::hx::Class Mods_obj::__mClass;

static ::String Mods_obj_sStaticFields[] = {
	HX_("currentModDirectory",24,ad,ec,de),
	HX_("ignoreModFolders",15,37,dd,7e),
	HX_("globalMods",74,1e,04,3f),
	HX_("getGlobalMods",aa,7a,76,9b),
	HX_("pushGlobalMods",ee,c8,dc,25),
	HX_("getModDirectories",9f,5f,dc,88),
	HX_("mergeAllTextsNamed",5c,f5,10,e0),
	HX_("directoriesWithFile",cd,86,61,2f),
	HX_("getPack",8f,86,d4,1c),
	HX_("updatedOnState",77,07,c7,9a),
	HX_("parseList",31,6e,59,cf),
	HX_("updateModList",37,4d,4d,a8),
	HX_("loadTopMod",f3,21,4e,4a),
	::String(null())
};

void Mods_obj::__register()
{
	Mods_obj _hx_dummy;
	Mods_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.Mods",2b,aa,ba,a1);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Mods_obj::__GetStatic;
	__mClass->mSetStaticField = &Mods_obj::__SetStatic;
	__mClass->mMarkFunc = Mods_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Mods_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Mods_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Mods_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Mods_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Mods_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Mods_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_13_boot)
HXDLIN(  13)		currentModDirectory = HX_("",00,00,00,00);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_14_boot)
HXDLIN(  14)		ignoreModFolders = ::Array_obj< ::String >::fromData( _hx_array_data_a1baaa2b_29,15);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_32_boot)
HXDLIN(  32)		globalMods = ::Array_obj< ::String >::__new(0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_147_boot)
HXDLIN( 147)		updatedOnState = false;
            	}
}

} // end namespace backend
