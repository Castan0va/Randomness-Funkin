// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_DiscordClient
#include <backend/DiscordClient.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxBackdrop
#include <flixel/addons/display/FlxBackdrop.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxGridOverlay
#include <flixel/addons/display/FlxGridOverlay.h>
#endif
#ifndef INCLUDED_flixel_addons_display_shapes_FlxShape
#include <flixel/addons/display/shapes/FlxShape.h>
#endif
#ifndef INCLUDED_flixel_addons_display_shapes_FlxShapeCircle
#include <flixel/addons/display/shapes/FlxShapeCircle.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedContainer
#include <flixel/group/FlxTypedContainer.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadAnalogStick
#include <flixel/input/gamepad/FlxGamepadAnalogStick.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxGamepadMapping
#include <flixel/input/gamepad/mappings/FlxGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSoundGroup
#include <flixel/sound/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxGradient
#include <flixel/util/FlxGradient.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_lime_system_Clipboard
#include <lime/system/Clipboard.h>
#endif
#ifndef INCLUDED_objects_Alignment
#include <objects/Alignment.h>
#endif
#ifndef INCLUDED_objects_AlphaCharacter
#include <objects/AlphaCharacter.h>
#endif
#ifndef INCLUDED_objects_Alphabet
#include <objects/Alphabet.h>
#endif
#ifndef INCLUDED_objects_Note
#include <objects/Note.h>
#endif
#ifndef INCLUDED_objects_StrumNote
#include <objects/StrumNote.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_media_Sound
#include <openfl/media/Sound.h>
#endif
#ifndef INCLUDED_options_NotesSubState
#include <options/NotesSubState.h>
#endif
#ifndef INCLUDED_shaders_RGBPalette
#include <shaders/RGBPalette.h>
#endif
#ifndef INCLUDED_shaders_RGBPaletteShader
#include <shaders/RGBPaletteShader.h>
#endif
#ifndef INCLUDED_shaders_RGBShaderReference
#include <shaders/RGBShaderReference.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_13db6fe15635f7e3_16_new,"options.NotesSubState","new",0xf0ea0e94,"options.NotesSubState.new","options/NotesSubState.hx",16,0x2831b15d)
static const int _hx_array_data_0afa74a2_1[] = {
	(int)-1,(int)-16777216,
};
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_173_updateTip,"options.NotesSubState","updateTip",0xad1a1c06,"options.NotesSubState.updateTip","options/NotesSubState.hx",173,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_184_update,"options.NotesSubState","update",0xb5c92055,"options.NotesSubState.update","options/NotesSubState.hx",184,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_371_update,"options.NotesSubState","update",0xb5c92055,"options.NotesSubState.update","options/NotesSubState.hx",371,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_384_update,"options.NotesSubState","update",0xb5c92055,"options.NotesSubState.update","options/NotesSubState.hx",384,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_496_pointerOverlaps,"options.NotesSubState","pointerOverlaps",0x070d911d,"options.NotesSubState.pointerOverlaps","options/NotesSubState.hx",496,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_502_pointerX,"options.NotesSubState","pointerX",0xc6feaa47,"options.NotesSubState.pointerX","options/NotesSubState.hx",502,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_507_pointerY,"options.NotesSubState","pointerY",0xc6feaa48,"options.NotesSubState.pointerY","options/NotesSubState.hx",507,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_512_pointerFlxPoint,"options.NotesSubState","pointerFlxPoint",0x6b9ac08f,"options.NotesSubState.pointerFlxPoint","options/NotesSubState.hx",512,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_518_centerHexTypeLine,"options.NotesSubState","centerHexTypeLine",0x8b4ee728,"options.NotesSubState.centerHexTypeLine","options/NotesSubState.hx",518,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_534_changeSelectionMode,"options.NotesSubState","changeSelectionMode",0x44e98c73,"options.NotesSubState.changeSelectionMode","options/NotesSubState.hx",534,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_546_changeSelectionNote,"options.NotesSubState","changeSelectionNote",0x4592d102,"options.NotesSubState.changeSelectionNote","options/NotesSubState.hx",546,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_563_makeColorAlphabet,"options.NotesSubState","makeColorAlphabet",0x796c6f9c,"options.NotesSubState.makeColorAlphabet","options/NotesSubState.hx",563,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_582_spawnNotes,"options.NotesSubState","spawnNotes",0x9defe852,"options.NotesSubState.spawnNotes","options/NotesSubState.hx",582,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_586_spawnNotes,"options.NotesSubState","spawnNotes",0x9defe852,"options.NotesSubState.spawnNotes","options/NotesSubState.hx",586,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_577_spawnNotes,"options.NotesSubState","spawnNotes",0x9defe852,"options.NotesSubState.spawnNotes","options/NotesSubState.hx",577,0x2831b15d)
static const int _hx_array_data_0afa74a2_23[] = {
	(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_658_updateNotes,"options.NotesSubState","updateNotes",0x4c70d7ac,"options.NotesSubState.updateNotes","options/NotesSubState.hx",658,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_674_updateColors,"options.NotesSubState","updateColors",0x2b1cc7e5,"options.NotesSubState.updateColors","options/NotesSubState.hx",674,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_705_setShaderColor,"options.NotesSubState","setShaderColor",0xcbe01dc8,"options.NotesSubState.setShaderColor","options/NotesSubState.hx",705,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_706_getShaderColor,"options.NotesSubState","getShaderColor",0xabc03554,"options.NotesSubState.getShaderColor","options/NotesSubState.hx",706,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_707_getShader,"options.NotesSubState","getShader",0xc3ac258f,"options.NotesSubState.getShader","options/NotesSubState.hx",707,0x2831b15d)
namespace options{

void NotesSubState_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_16_new)
HXLINE( 179)		 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN( 179)		_g->set(48,HX_("0",30,00,00,00));
HXDLIN( 179)		_g->set(49,HX_("1",31,00,00,00));
HXDLIN( 179)		_g->set(50,HX_("2",32,00,00,00));
HXDLIN( 179)		_g->set(51,HX_("3",33,00,00,00));
HXDLIN( 179)		_g->set(52,HX_("4",34,00,00,00));
HXDLIN( 179)		_g->set(53,HX_("5",35,00,00,00));
HXDLIN( 179)		_g->set(54,HX_("6",36,00,00,00));
HXDLIN( 179)		_g->set(55,HX_("7",37,00,00,00));
HXDLIN( 179)		_g->set(56,HX_("8",38,00,00,00));
HXDLIN( 179)		_g->set(57,HX_("9",39,00,00,00));
HXDLIN( 179)		_g->set(96,HX_("0",30,00,00,00));
HXDLIN( 179)		_g->set(97,HX_("1",31,00,00,00));
HXDLIN( 179)		_g->set(98,HX_("2",32,00,00,00));
HXDLIN( 179)		_g->set(99,HX_("3",33,00,00,00));
HXDLIN( 179)		_g->set(100,HX_("4",34,00,00,00));
HXDLIN( 179)		_g->set(101,HX_("5",35,00,00,00));
HXDLIN( 179)		_g->set(102,HX_("6",36,00,00,00));
HXDLIN( 179)		_g->set(103,HX_("7",37,00,00,00));
HXDLIN( 179)		_g->set(104,HX_("8",38,00,00,00));
HXDLIN( 179)		_g->set(105,HX_("9",39,00,00,00));
HXDLIN( 179)		_g->set(65,HX_("A",41,00,00,00));
HXDLIN( 179)		_g->set(66,HX_("B",42,00,00,00));
HXDLIN( 179)		_g->set(67,HX_("C",43,00,00,00));
HXDLIN( 179)		_g->set(68,HX_("D",44,00,00,00));
HXDLIN( 179)		_g->set(69,HX_("E",45,00,00,00));
HXDLIN( 179)		_g->set(70,HX_("F",46,00,00,00));
HXDLIN( 179)		this->allowedTypeKeys = _g;
HXLINE( 177)		this->changingNote = false;
HXLINE(  47)		this->_lastControllerMode = false;
HXLINE(  26)		this->hexTypeVisibleTimer = ((Float)0);
HXLINE(  25)		this->hexTypeNum = -1;
HXLINE(  21)		this->onPixel = false;
HXLINE(  20)		this->curSelectedNote = 0;
HXLINE(  19)		this->curSelectedMode = 0;
HXLINE(  18)		this->onModeColumn = true;
HXLINE(  51)		super::__construct();
HXLINE(  54)		::backend::DiscordClient_obj::changePresence(HX_("Note Colors Menu",01,01,06,42),null(),null(),null(),null());
HXLINE(  57)		 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  57)		 ::flixel::FlxSprite bg1 = bg->loadGraphic(::backend::Paths_obj::image(HX_("menuDesat",26,91,04,72),null(),null()),null(),null(),null(),null(),null());
HXLINE(  58)		bg1->set_color(-1412611);
HXLINE(  59)		{
HXLINE(  59)			int axes = 17;
HXDLIN(  59)			bool _hx_tmp;
HXDLIN(  59)			if ((axes != 1)) {
HXLINE(  59)				_hx_tmp = (axes == 17);
            			}
            			else {
HXLINE(  59)				_hx_tmp = true;
            			}
HXDLIN(  59)			if (_hx_tmp) {
HXLINE(  59)				int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN(  59)				bg1->set_x(((( (Float)(_hx_tmp1) ) - bg1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  59)			bool _hx_tmp2;
HXDLIN(  59)			if ((axes != 16)) {
HXLINE(  59)				_hx_tmp2 = (axes == 17);
            			}
            			else {
HXLINE(  59)				_hx_tmp2 = true;
            			}
HXDLIN(  59)			if (_hx_tmp2) {
HXLINE(  59)				int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN(  59)				bg1->set_y(((( (Float)(_hx_tmp3) ) - bg1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  60)		bg1->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE(  61)		this->add(bg1);
HXLINE(  63)		 ::flixel::addons::display::FlxBackdrop grid =  ::flixel::addons::display::FlxBackdrop_obj::__alloc( HX_CTX ,::flixel::addons::display::FlxGridOverlay_obj::createGrid(80,80,160,160,true,872415231,0),null(),null(),null());
HXLINE(  64)		{
HXLINE(  64)			 ::flixel::math::FlxBasePoint this1 = grid->velocity;
HXDLIN(  64)			this1->set_x(( (Float)(40) ));
HXDLIN(  64)			this1->set_y(( (Float)(40) ));
            		}
HXLINE(  65)		grid->set_alpha(( (Float)(0) ));
HXLINE(  66)		::flixel::tweens::FlxTween_obj::tween(grid, ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("alpha",5e,a7,96,21),1)),((Float)0.5), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::quadOut_dyn())));
HXLINE(  67)		this->add(grid);
HXLINE(  69)		this->modeBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,215,85,null())->makeGraphic(315,115,-16777216,null(),null());
HXLINE(  70)		this->modeBG->set_visible(false);
HXLINE(  71)		this->modeBG->set_alpha(((Float)0.4));
HXLINE(  72)		this->add(this->modeBG);
HXLINE(  74)		this->notesBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,140,190,null())->makeGraphic(480,125,-16777216,null(),null());
HXLINE(  75)		this->notesBG->set_visible(false);
HXLINE(  76)		this->notesBG->set_alpha(((Float)0.4));
HXLINE(  77)		this->add(this->notesBG);
HXLINE(  79)		this->modeNotes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  80)		this->add(this->modeNotes);
HXLINE(  82)		this->myNotes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  83)		this->add(this->myNotes);
HXLINE(  85)		 ::flixel::FlxSprite bg2 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,720,null(),null());
HXDLIN(  85)		 ::flixel::FlxSprite bg3 = bg2->makeGraphic((::flixel::FlxG_obj::width - 720),::flixel::FlxG_obj::height,-16777216,null(),null());
HXLINE(  86)		bg3->set_alpha(((Float)0.25));
HXLINE(  87)		this->add(bg3);
HXLINE(  88)		 ::flixel::FlxSprite bg4 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,750,160,null());
HXDLIN(  88)		 ::flixel::FlxSprite bg5 = bg4->makeGraphic((::flixel::FlxG_obj::width - 780),540,-16777216,null(),null());
HXLINE(  89)		bg5->set_alpha(((Float)0.25));
HXLINE(  90)		this->add(bg5);
HXLINE(  92)		 ::objects::Alphabet text =  ::objects::Alphabet_obj::__alloc( HX_CTX ,( (Float)(50) ),( (Float)(86) ),HX_("CTRL",ab,50,89,2c),false);
HXLINE(  93)		text->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE(  94)		text->setScale(((Float)0.4),null());
HXLINE(  95)		this->add(text);
HXLINE(  97)		 ::flixel::FlxSprite _hx_tmp4 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,760,50,null());
HXDLIN(  97)		this->copyButton = _hx_tmp4->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/copy",14,93,08,23),null(),null()),null(),null(),null(),null(),null());
HXLINE(  98)		this->copyButton->set_alpha(((Float)0.6));
HXLINE(  99)		this->add(this->copyButton);
HXLINE( 101)		 ::flixel::FlxSprite _hx_tmp5 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,1180,50,null());
HXDLIN( 101)		this->pasteButton = _hx_tmp5->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/paste",14,ef,6e,f7),null(),null()),null(),null(),null(),null(),null());
HXLINE( 102)		this->pasteButton->set_alpha(((Float)0.6));
HXLINE( 103)		this->add(this->pasteButton);
HXLINE( 105)		this->colorGradient = ::flixel::util::FlxGradient_obj::createGradientFlxSprite(60,360,::Array_obj< int >::fromData( _hx_array_data_0afa74a2_1,2),null(),null(),null());
HXLINE( 106)		this->colorGradient->setPosition(780,200);
HXLINE( 107)		this->add(this->colorGradient);
HXLINE( 109)		this->colorGradientSelector =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,770,200,null())->makeGraphic(80,10,-1,null(),null());
HXLINE( 110)		this->colorGradientSelector->offset->set_y(( (Float)(5) ));
HXLINE( 111)		this->add(this->colorGradientSelector);
HXLINE( 113)		 ::flixel::FlxSprite _hx_tmp6 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,820,580,null());
HXDLIN( 113)		this->colorPalette = _hx_tmp6->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/palette",7c,60,ab,d2),null(),false),null(),null(),null(),null(),null());
HXLINE( 114)		{
HXLINE( 114)			 ::flixel::math::FlxBasePoint this2 = this->colorPalette->scale;
HXDLIN( 114)			this2->set_x(( (Float)(20) ));
HXDLIN( 114)			this2->set_y(( (Float)(20) ));
            		}
HXLINE( 115)		this->colorPalette->updateHitbox();
HXLINE( 116)		this->colorPalette->set_antialiasing(false);
HXLINE( 117)		this->add(this->colorPalette);
HXLINE( 119)		 ::flixel::FlxSprite _hx_tmp7 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,860,200,null());
HXDLIN( 119)		this->colorWheel = _hx_tmp7->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/colorWheel",d7,74,dc,98),null(),null()),null(),null(),null(),null(),null());
HXLINE( 120)		this->colorWheel->setGraphicSize(360,360);
HXLINE( 121)		this->colorWheel->updateHitbox();
HXLINE( 122)		this->add(this->colorWheel);
HXLINE( 124)		this->colorWheelSelector =  ::flixel::addons::display::shapes::FlxShapeCircle_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),( (Float)(8) ), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("thickness",74,f1,66,5a),0)),-1);
HXLINE( 125)		{
HXLINE( 125)			 ::flixel::math::FlxBasePoint this3 = this->colorWheelSelector->offset;
HXDLIN( 125)			this3->set_x(( (Float)(8) ));
HXDLIN( 125)			this3->set_y(( (Float)(8) ));
            		}
HXLINE( 126)		this->colorWheelSelector->set_alpha(((Float)0.6));
HXLINE( 127)		this->add(this->colorWheelSelector);
HXLINE( 129)		int txtX = 980;
HXLINE( 130)		int txtY = 90;
HXLINE( 131)		this->alphabetR = this->makeColorAlphabet((txtX - 100),txtY);
HXLINE( 132)		this->add(this->alphabetR);
HXLINE( 133)		this->alphabetG = this->makeColorAlphabet(txtX,txtY);
HXLINE( 134)		this->add(this->alphabetG);
HXLINE( 135)		this->alphabetB = this->makeColorAlphabet((txtX + 100),txtY);
HXLINE( 136)		this->add(this->alphabetB);
HXLINE( 137)		this->alphabetHex = this->makeColorAlphabet(txtX,(txtY - 55));
HXLINE( 138)		this->add(this->alphabetHex);
HXLINE( 139)		this->hexTypeLine =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,20,null())->makeGraphic(5,62,-1,null(),null());
HXLINE( 140)		this->hexTypeLine->set_visible(false);
HXLINE( 141)		this->add(this->hexTypeLine);
HXLINE( 143)		this->spawnNotes();
HXLINE( 144)		this->updateNotes(true);
HXLINE( 145)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp8 = ::flixel::FlxG_obj::sound;
HXDLIN( 145)		_hx_tmp8->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 147)		int tipX = 20;
HXLINE( 148)		int tipY = 660;
HXLINE( 149)		 ::flixel::text::FlxText tip =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,tipX,tipY,0,HX_("Press RELOAD to Reset the selected Note Part.",b7,56,2a,49),16,null());
HXLINE( 150)		::String file = ::backend::Paths_obj::modFolders((HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82)));
HXDLIN( 150)		::String _hx_tmp9;
HXDLIN( 150)		if (::sys::FileSystem_obj::exists(file)) {
HXLINE( 150)			_hx_tmp9 = file;
            		}
            		else {
HXLINE( 150)			_hx_tmp9 = (HX_("assets/fonts/",37,ff,a5,9c) + HX_("vcr.ttf",9d,d2,a7,82));
            		}
HXDLIN( 150)		tip->setFormat(_hx_tmp9,16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 151)		tip->set_borderSize(( (Float)(2) ));
HXLINE( 152)		this->add(tip);
HXLINE( 154)		this->tipTxt =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,tipX,(tipY + 24),0,HX_("",00,00,00,00),16,null());
HXLINE( 155)		 ::flixel::text::FlxText _hx_tmp10 = this->tipTxt;
HXDLIN( 155)		::String file1 = ::backend::Paths_obj::modFolders((HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82)));
HXDLIN( 155)		::String _hx_tmp11;
HXDLIN( 155)		if (::sys::FileSystem_obj::exists(file1)) {
HXLINE( 155)			_hx_tmp11 = file1;
            		}
            		else {
HXLINE( 155)			_hx_tmp11 = (HX_("assets/fonts/",37,ff,a5,9c) + HX_("vcr.ttf",9d,d2,a7,82));
            		}
HXDLIN( 155)		_hx_tmp10->setFormat(_hx_tmp11,16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 156)		this->tipTxt->set_borderSize(( (Float)(2) ));
HXLINE( 157)		this->add(this->tipTxt);
HXLINE( 158)		this->updateTip();
HXLINE( 160)		this->controllerPointer =  ::flixel::addons::display::shapes::FlxShapeCircle_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),( (Float)(20) ), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("thickness",74,f1,66,5a),0)),-1);
HXLINE( 161)		{
HXLINE( 161)			 ::flixel::math::FlxBasePoint this4 = this->controllerPointer->offset;
HXDLIN( 161)			this4->set_x(( (Float)(20) ));
HXDLIN( 161)			this4->set_y(( (Float)(20) ));
            		}
HXLINE( 162)		{
HXLINE( 162)			 ::flixel::FlxSprite _this = this->controllerPointer;
HXDLIN( 162)			int axes1 = 17;
HXDLIN( 162)			bool _hx_tmp12;
HXDLIN( 162)			if ((axes1 != 1)) {
HXLINE( 162)				_hx_tmp12 = (axes1 == 17);
            			}
            			else {
HXLINE( 162)				_hx_tmp12 = true;
            			}
HXDLIN( 162)			if (_hx_tmp12) {
HXLINE( 162)				int _hx_tmp13 = ::flixel::FlxG_obj::width;
HXDLIN( 162)				_this->set_x(((( (Float)(_hx_tmp13) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN( 162)			bool _hx_tmp14;
HXDLIN( 162)			if ((axes1 != 16)) {
HXLINE( 162)				_hx_tmp14 = (axes1 == 17);
            			}
            			else {
HXLINE( 162)				_hx_tmp14 = true;
            			}
HXDLIN( 162)			if (_hx_tmp14) {
HXLINE( 162)				int _hx_tmp15 = ::flixel::FlxG_obj::height;
HXDLIN( 162)				_this->set_y(((( (Float)(_hx_tmp15) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 163)		this->controllerPointer->set_alpha(((Float)0.6));
HXLINE( 164)		this->add(this->controllerPointer);
HXLINE( 166)		::flixel::FlxG_obj::mouse->set_visible(!(::backend::Controls_obj::instance->controllerMode));
HXLINE( 167)		this->controllerPointer->set_visible(::backend::Controls_obj::instance->controllerMode);
HXLINE( 168)		this->_lastControllerMode = ::backend::Controls_obj::instance->controllerMode;
            	}

Dynamic NotesSubState_obj::__CreateEmpty() { return new NotesSubState_obj; }

void *NotesSubState_obj::_hx_vtable = 0;

Dynamic NotesSubState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NotesSubState_obj > _hx_result = new NotesSubState_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool NotesSubState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5661ffbf) {
		if (inClassId<=(int)0x3c0818b8) {
			if (inClassId<=(int)0x1154fc14) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1154fc14;
			} else {
				return inClassId==(int)0x3c0818b8;
			}
		} else {
			return inClassId==(int)0x563293a6 || inClassId==(int)0x5661ffbf;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

void NotesSubState_obj::updateTip(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_173_updateTip)
HXDLIN( 173)		::String _hx_tmp;
HXDLIN( 173)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXDLIN( 173)			_hx_tmp = HX_("Shift",62,5c,50,0f);
            		}
            		else {
HXDLIN( 173)			_hx_tmp = HX_("Left Shoulder Button",b9,84,12,11);
            		}
HXDLIN( 173)		this->tipTxt->set_text(((HX_("Hold ",e1,bd,8a,be) + _hx_tmp) + HX_(" + Press RESET key to fully reset the selected Note.",2e,35,80,12)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,updateTip,(void))

void NotesSubState_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_184_update)
HXDLIN( 184)		 ::options::NotesSubState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 185)		if (::backend::Controls_obj::instance->get_BACK()) {
HXLINE( 186)			::flixel::FlxG_obj::mouse->set_visible(false);
HXLINE( 187)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 187)			_hx_tmp->play(::backend::Paths_obj::sound(HX_("cancelMenu",39,a4,43,b7),null()),null(),null(),null(),null(),null());
HXLINE( 188)			this->close();
HXLINE( 189)			return;
            		}
HXLINE( 192)		this->super::update(elapsed);
HXLINE( 195)		if (::flixel::FlxG_obj::gamepads->anyHasState(-2,2)) {
HXLINE( 195)			::backend::Controls_obj::instance->controllerMode = true;
            		}
            		else {
HXLINE( 196)			bool _hx_tmp1;
HXDLIN( 196)			bool _hx_tmp2;
HXDLIN( 196)			if ((::flixel::FlxG_obj::mouse->_leftButton->current != 2)) {
HXLINE( 196)				 ::flixel::input::mouse::FlxMouse _this = ::flixel::FlxG_obj::mouse;
HXDLIN( 196)				_hx_tmp2 = ((_this->screenX - _this->_prevScreenX) != 0);
            			}
            			else {
HXLINE( 196)				_hx_tmp2 = true;
            			}
HXDLIN( 196)			if (!(_hx_tmp2)) {
HXLINE( 196)				 ::flixel::input::mouse::FlxMouse _this1 = ::flixel::FlxG_obj::mouse;
HXDLIN( 196)				_hx_tmp1 = ((_this1->screenY - _this1->_prevScreenY) != 0);
            			}
            			else {
HXLINE( 196)				_hx_tmp1 = true;
            			}
HXDLIN( 196)			if (_hx_tmp1) {
HXLINE( 196)				::backend::Controls_obj::instance->controllerMode = false;
            			}
            		}
HXLINE( 199)		bool changedToController = false;
HXLINE( 200)		if ((::backend::Controls_obj::instance->controllerMode != this->_lastControllerMode)) {
HXLINE( 203)			::flixel::FlxG_obj::mouse->set_visible(!(::backend::Controls_obj::instance->controllerMode));
HXLINE( 204)			this->controllerPointer->set_visible(::backend::Controls_obj::instance->controllerMode);
HXLINE( 207)			if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 209)				this->controllerPointer->set_x(( (Float)(::flixel::FlxG_obj::mouse->x) ));
HXLINE( 210)				this->controllerPointer->set_y(( (Float)(::flixel::FlxG_obj::mouse->y) ));
HXLINE( 211)				changedToController = true;
            			}
HXLINE( 221)			this->_lastControllerMode = ::backend::Controls_obj::instance->controllerMode;
HXLINE( 222)			this->updateTip();
            		}
HXLINE( 226)		Float analogX = ( (Float)(0) );
HXLINE( 227)		Float analogY = ( (Float)(0) );
HXLINE( 228)		bool analogMoved = false;
HXLINE( 229)		bool _hx_tmp3;
HXDLIN( 229)		if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 229)			if (!(changedToController)) {
HXLINE( 229)				_hx_tmp3 = ::flixel::FlxG_obj::gamepads->anyInput();
            			}
            			else {
HXLINE( 229)				_hx_tmp3 = true;
            			}
            		}
            		else {
HXLINE( 229)			_hx_tmp3 = false;
            		}
HXDLIN( 229)		if (_hx_tmp3) {
HXLINE( 231)			{
HXLINE( 231)				int _g = 0;
HXDLIN( 231)				::Array< ::Dynamic> _g1 = ::flixel::FlxG_obj::gamepads->getActiveGamepads(null());
HXDLIN( 231)				while((_g < _g1->length)){
HXLINE( 231)					 ::flixel::input::gamepad::FlxGamepad gamepad = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepad >();
HXDLIN( 231)					_g = (_g + 1);
HXLINE( 233)					analogX = gamepad->getAnalogXAxisValue(gamepad->mapping->getAnalogStick(19));
HXLINE( 234)					analogY = gamepad->getYAxisRaw(gamepad->mapping->getAnalogStick(19));
HXLINE( 235)					if ((analogX == 0)) {
HXLINE( 235)						analogMoved = (analogY != 0);
            					}
            					else {
HXLINE( 235)						analogMoved = true;
            					}
HXLINE( 236)					if (analogMoved) {
HXLINE( 236)						goto _hx_goto_3;
            					}
            				}
            				_hx_goto_3:;
            			}
HXLINE( 238)			this->controllerPointer->set_x(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)(::flixel::FlxG_obj::width) ),(this->controllerPointer->x + ((analogX * ( (Float)(1000) )) * elapsed)))));
HXLINE( 239)			this->controllerPointer->set_y(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)(::flixel::FlxG_obj::height) ),(this->controllerPointer->y + ((analogY * ( (Float)(1000) )) * elapsed)))));
            		}
HXLINE( 241)		bool controllerPressed;
HXDLIN( 241)		if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 241)			controllerPressed = ::backend::Controls_obj::instance->get_ACCEPT();
            		}
            		else {
HXLINE( 241)			controllerPressed = false;
            		}
HXLINE( 244)		 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 244)		if (_this2->keyManager->checkStatusUnsafe(17,_this2->status)) {
HXLINE( 246)			this->onPixel = !(this->onPixel);
HXLINE( 247)			this->spawnNotes();
HXLINE( 248)			this->updateNotes(true);
HXLINE( 249)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp4 = ::flixel::FlxG_obj::sound;
HXDLIN( 249)			_hx_tmp4->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            		}
HXLINE( 252)		if ((this->hexTypeNum > -1)) {
HXLINE( 254)			int keyPressed = ::flixel::FlxG_obj::keys->firstJustPressed();
HXLINE( 255)			 ::options::NotesSubState _hx_tmp5 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 255)			_hx_tmp5->hexTypeVisibleTimer = (_hx_tmp5->hexTypeVisibleTimer + elapsed);
HXLINE( 256)			bool changed = false;
HXLINE( 257)			 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 257)			changed = _this3->keyManager->checkStatusUnsafe(37,_this3->status);
HXDLIN( 257)			if (changed) {
HXLINE( 258)				this->hexTypeNum--;
            			}
            			else {
HXLINE( 259)				 ::flixel::input::keyboard::FlxKeyList _this4 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 259)				changed = _this4->keyManager->checkStatusUnsafe(39,_this4->status);
HXDLIN( 259)				if (changed) {
HXLINE( 260)					this->hexTypeNum++;
            				}
            				else {
HXLINE( 261)					if (this->allowedTypeKeys->exists(keyPressed)) {
HXLINE( 264)						::String curColor = this->alphabetHex->text;
HXLINE( 265)						::String newColor = curColor.substring(0,this->hexTypeNum);
HXDLIN( 265)						::String newColor1 = (newColor + this->allowedTypeKeys->get(keyPressed));
HXDLIN( 265)						::String newColor2 = (newColor1 + curColor.substring((this->hexTypeNum + 1),null()));
HXLINE( 267)						int colorHex = ( (int)(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString((HX_("#",23,00,00,00) + newColor2))) );
HXLINE( 268)						this->setShaderColor(colorHex);
HXLINE( 269)						this->_storedColor = this->getShaderColor();
HXLINE( 270)						this->updateColors(null());
HXLINE( 273)						this->hexTypeNum++;
HXLINE( 274)						changed = true;
            					}
            					else {
HXLINE( 276)						 ::flixel::input::keyboard::FlxKeyList _this5 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 276)						if (_this5->keyManager->checkStatusUnsafe(13,_this5->status)) {
HXLINE( 277)							this->hexTypeNum = -1;
            						}
            					}
            				}
            			}
HXLINE( 279)			bool end = false;
HXLINE( 280)			if (changed) {
HXLINE( 282)				if ((this->hexTypeNum > 5)) {
HXLINE( 284)					this->hexTypeNum = -1;
HXLINE( 285)					end = true;
HXLINE( 286)					this->hexTypeLine->set_visible(false);
            				}
            				else {
HXLINE( 290)					if ((this->hexTypeNum < 0)) {
HXLINE( 290)						this->hexTypeNum = 0;
            					}
            					else {
HXLINE( 291)						if ((this->hexTypeNum > 5)) {
HXLINE( 291)							this->hexTypeNum = 5;
            						}
            					}
HXLINE( 292)					this->centerHexTypeLine();
HXLINE( 293)					this->hexTypeLine->set_visible(true);
            				}
HXLINE( 295)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp6 = ::flixel::FlxG_obj::sound;
HXDLIN( 295)				_hx_tmp6->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            			}
HXLINE( 297)			if (!(end)) {
HXLINE( 297)				this->hexTypeLine->set_visible((::hx::Mod(::Math_obj::floor((this->hexTypeVisibleTimer * ( (Float)(2) ))),2) == 0));
            			}
            		}
            		else {
HXLINE( 301)			int add = 0;
HXLINE( 302)			bool _hx_tmp7;
HXDLIN( 302)			if ((analogX == 0)) {
HXLINE( 302)				_hx_tmp7 = !(changedToController);
            			}
            			else {
HXLINE( 302)				_hx_tmp7 = false;
            			}
HXDLIN( 302)			if (_hx_tmp7) {
HXLINE( 304)				if (::backend::Controls_obj::instance->get_UI_LEFT_P()) {
HXLINE( 304)					add = -1;
            				}
            				else {
HXLINE( 305)					if (::backend::Controls_obj::instance->get_UI_RIGHT_P()) {
HXLINE( 305)						add = 1;
            					}
            				}
            			}
HXLINE( 308)			bool _hx_tmp8;
HXDLIN( 308)			bool _hx_tmp9;
HXDLIN( 308)			if ((analogY == 0)) {
HXLINE( 308)				_hx_tmp9 = !(changedToController);
            			}
            			else {
HXLINE( 308)				_hx_tmp9 = false;
            			}
HXDLIN( 308)			if (_hx_tmp9) {
HXLINE( 308)				if (!(::backend::Controls_obj::instance->get_UI_UP_P())) {
HXLINE( 308)					_hx_tmp8 = ::backend::Controls_obj::instance->get_UI_DOWN_P();
            				}
            				else {
HXLINE( 308)					_hx_tmp8 = true;
            				}
            			}
            			else {
HXLINE( 308)				_hx_tmp8 = false;
            			}
HXDLIN( 308)			if (_hx_tmp8) {
HXLINE( 310)				this->onModeColumn = !(this->onModeColumn);
HXLINE( 311)				this->modeBG->set_visible(this->onModeColumn);
HXLINE( 312)				this->notesBG->set_visible(!(this->onModeColumn));
            			}
HXLINE( 315)			if ((add != 0)) {
HXLINE( 317)				if (this->onModeColumn) {
HXLINE( 317)					this->changeSelectionMode(add);
            				}
            				else {
HXLINE( 318)					this->changeSelectionNote(add);
            				}
            			}
HXLINE( 320)			this->hexTypeLine->set_visible(false);
            		}
HXLINE( 324)		bool generalMoved;
HXDLIN( 324)		 ::flixel::input::mouse::FlxMouse _this6 = ::flixel::FlxG_obj::mouse;
HXDLIN( 324)		bool generalMoved1;
HXDLIN( 324)		if ((_this6->_prevX == _this6->x)) {
HXLINE( 324)			generalMoved1 = (_this6->_prevY != _this6->y);
            		}
            		else {
HXLINE( 324)			generalMoved1 = true;
            		}
HXDLIN( 324)		if (!(generalMoved1)) {
HXLINE( 324)			generalMoved = analogMoved;
            		}
            		else {
HXLINE( 324)			generalMoved = true;
            		}
HXLINE( 325)		bool generalPressed;
HXDLIN( 325)		if ((::flixel::FlxG_obj::mouse->_leftButton->current != 2)) {
HXLINE( 325)			generalPressed = controllerPressed;
            		}
            		else {
HXLINE( 325)			generalPressed = true;
            		}
HXLINE( 326)		if (generalMoved) {
HXLINE( 328)			this->copyButton->set_alpha(((Float)0.6));
HXLINE( 329)			this->pasteButton->set_alpha(((Float)0.6));
            		}
HXLINE( 332)		if (this->pointerOverlaps(this->copyButton)) {
HXLINE( 334)			this->copyButton->set_alpha(( (Float)(1) ));
HXLINE( 335)			if (generalPressed) {
HXLINE( 337)				int this1 = this->getShaderColor();
HXDLIN( 337)				::String _hx_tmp10 = (HX_("",00,00,00,00) + ::StringTools_obj::hex(((this1 >> 16) & 255),2));
HXDLIN( 337)				::String _hx_tmp11 = (_hx_tmp10 + ::StringTools_obj::hex(((this1 >> 8) & 255),2));
HXDLIN( 337)				::lime::_hx_system::Clipboard_obj::set_text((_hx_tmp11 + ::StringTools_obj::hex((this1 & 255),2)));
HXLINE( 338)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp12 = ::flixel::FlxG_obj::sound;
HXDLIN( 338)				_hx_tmp12->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 339)				 ::Dynamic _hx_tmp13 = ::haxe::Log_obj::trace;
HXDLIN( 339)				::String _hx_tmp14 = (HX_("copied: ",ea,92,6a,a6) + ::lime::_hx_system::Clipboard_obj::get_text());
HXDLIN( 339)				_hx_tmp13(_hx_tmp14,::hx::SourceInfo(HX_("source/options/NotesSubState.hx",51,fc,98,b4),339,HX_("options.NotesSubState",a2,74,fa,0a),HX_("update",09,86,05,87)));
            			}
HXLINE( 341)			this->hexTypeNum = -1;
            		}
            		else {
HXLINE( 343)			if (this->pointerOverlaps(this->pasteButton)) {
HXLINE( 345)				this->pasteButton->set_alpha(( (Float)(1) ));
HXLINE( 346)				if (generalPressed) {
HXLINE( 348)					::String formattedText = ::StringTools_obj::replace(::StringTools_obj::replace(::StringTools_obj::trim(::lime::_hx_system::Clipboard_obj::get_text()).toUpperCase(),HX_("#",23,00,00,00),HX_("",00,00,00,00)),HX_("0x",48,2a,00,00),HX_("",00,00,00,00));
HXLINE( 349)					 ::Dynamic newColor3 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString((HX_("#",23,00,00,00) + formattedText));
HXLINE( 351)					bool _hx_tmp15;
HXDLIN( 351)					if (::hx::IsNotNull( newColor3 )) {
HXLINE( 351)						_hx_tmp15 = (formattedText.length == 6);
            					}
            					else {
HXLINE( 351)						_hx_tmp15 = false;
            					}
HXDLIN( 351)					if (_hx_tmp15) {
HXLINE( 353)						this->setShaderColor(( (int)(newColor3) ));
HXLINE( 354)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp16 = ::flixel::FlxG_obj::sound;
HXDLIN( 354)						_hx_tmp16->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 355)						this->_storedColor = this->getShaderColor();
HXLINE( 356)						this->updateColors(null());
            					}
            					else {
HXLINE( 359)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp17 = ::flixel::FlxG_obj::sound;
HXDLIN( 359)						_hx_tmp17->play(::backend::Paths_obj::sound(HX_("cancelMenu",39,a4,43,b7),null()),((Float)0.6),null(),null(),null(),null());
            					}
            				}
HXLINE( 361)				this->hexTypeNum = -1;
            			}
            		}
HXLINE( 365)		if (generalPressed) {
HXLINE( 367)			this->hexTypeNum = -1;
HXLINE( 368)			if (this->pointerOverlaps(this->modeNotes)) {
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::options::NotesSubState,_gthis) HXARGC(1)
            				void _hx_run( ::flixel::FlxSprite note){
            					HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_371_update)
HXLINE( 371)					bool _hx_tmp;
HXDLIN( 371)					if ((_gthis->curSelectedMode != note->ID)) {
HXLINE( 371)						_hx_tmp = _gthis->pointerOverlaps(note);
            					}
            					else {
HXLINE( 371)						_hx_tmp = false;
            					}
HXDLIN( 371)					if (_hx_tmp) {
HXLINE( 373)						 ::flixel::FlxSprite _gthis1 = _gthis->modeBG;
HXDLIN( 373)						_gthis1->set_visible(_gthis->notesBG->set_visible(false));
HXLINE( 374)						_gthis->curSelectedMode = note->ID;
HXLINE( 375)						_gthis->onModeColumn = true;
HXLINE( 376)						_gthis->updateNotes(null());
HXLINE( 377)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 377)						_hx_tmp1->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            					}
            				}
            				HX_END_LOCAL_FUNC1((void))

HXLINE( 370)				this->modeNotes->forEachAlive( ::Dynamic(new _hx_Closure_0(_gthis)),null());
            			}
            			else {
HXLINE( 381)				if (this->pointerOverlaps(this->myNotes)) {
            					HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::options::NotesSubState,_gthis) HXARGC(1)
            					void _hx_run( ::objects::StrumNote note){
            						HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_384_update)
HXLINE( 384)						bool _hx_tmp;
HXDLIN( 384)						if ((_gthis->curSelectedNote != note->ID)) {
HXLINE( 384)							_hx_tmp = _gthis->pointerOverlaps(note);
            						}
            						else {
HXLINE( 384)							_hx_tmp = false;
            						}
HXDLIN( 384)						if (_hx_tmp) {
HXLINE( 386)							 ::flixel::FlxSprite _gthis1 = _gthis->modeBG;
HXDLIN( 386)							_gthis1->set_visible(_gthis->notesBG->set_visible(false));
HXLINE( 387)							_gthis->curSelectedNote = note->ID;
HXLINE( 388)							_gthis->onModeColumn = false;
HXLINE( 389)							_gthis->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(note->ID).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 390)							_gthis->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(note->ID).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 391)							_gthis->updateNotes(null());
HXLINE( 392)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 392)							_hx_tmp1->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            						}
            					}
            					HX_END_LOCAL_FUNC1((void))

HXLINE( 383)					this->myNotes->forEachAlive( ::Dynamic(new _hx_Closure_1(_gthis)),null());
            				}
            				else {
HXLINE( 396)					if (this->pointerOverlaps(this->colorWheel)) {
HXLINE( 397)						this->_storedColor = this->getShaderColor();
HXLINE( 398)						this->holdingOnObj = this->colorWheel;
            					}
            					else {
HXLINE( 400)						if (this->pointerOverlaps(this->colorGradient)) {
HXLINE( 401)							this->_storedColor = this->getShaderColor();
HXLINE( 402)							this->holdingOnObj = this->colorGradient;
            						}
            						else {
HXLINE( 404)							if (this->pointerOverlaps(this->colorPalette)) {
HXLINE( 405)								 ::openfl::display::BitmapData _hx_tmp18 = this->colorPalette->get_pixels();
HXLINE( 406)								Float _hx_tmp19 = this->pointerX();
HXDLIN( 406)								int _hx_tmp20 = ::Std_obj::_hx_int(((_hx_tmp19 - this->colorPalette->x) / this->colorPalette->scale->x));
HXLINE( 407)								Float _hx_tmp21 = this->pointerY();
HXLINE( 405)								this->setShaderColor(_hx_tmp18->getPixel32(_hx_tmp20,::Std_obj::_hx_int(((_hx_tmp21 - this->colorPalette->y) / this->colorPalette->scale->y))));
HXLINE( 408)								 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp22 = ::flixel::FlxG_obj::sound;
HXDLIN( 408)								_hx_tmp22->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 409)								this->updateColors(null());
            							}
            							else {
HXLINE( 411)								if (this->pointerOverlaps(this->skinNote)) {
HXLINE( 413)									this->onPixel = !(this->onPixel);
HXLINE( 414)									this->spawnNotes();
HXLINE( 415)									this->updateNotes(true);
HXLINE( 416)									 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp23 = ::flixel::FlxG_obj::sound;
HXDLIN( 416)									_hx_tmp23->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            								}
            								else {
HXLINE( 418)									bool _hx_tmp24;
HXDLIN( 418)									bool _hx_tmp25;
HXDLIN( 418)									Float _hx_tmp26 = this->pointerY();
HXDLIN( 418)									if ((_hx_tmp26 >= this->hexTypeLine->y)) {
HXLINE( 418)										Float _hx_tmp27 = this->pointerY();
HXDLIN( 418)										Float _hx_tmp28 = this->hexTypeLine->y;
HXDLIN( 418)										_hx_tmp25 = (_hx_tmp27 < (_hx_tmp28 + this->hexTypeLine->get_height()));
            									}
            									else {
HXLINE( 418)										_hx_tmp25 = false;
            									}
HXDLIN( 418)									if (_hx_tmp25) {
HXLINE( 418)										_hx_tmp24 = (::Math_obj::abs((this->pointerX() - ( (Float)(1000) ))) <= 84);
            									}
            									else {
HXLINE( 418)										_hx_tmp24 = false;
            									}
HXDLIN( 418)									if (_hx_tmp24) {
HXLINE( 421)										this->hexTypeNum = 0;
HXLINE( 422)										{
HXLINE( 422)											int _g2 = 0;
HXDLIN( 422)											::Array< ::Dynamic> _g3 = this->alphabetHex->letters;
HXDLIN( 422)											while((_g2 < _g3->length)){
HXLINE( 422)												 ::objects::AlphaCharacter letter = _g3->__get(_g2).StaticCast<  ::objects::AlphaCharacter >();
HXDLIN( 422)												_g2 = (_g2 + 1);
HXLINE( 424)												Float _hx_tmp29 = (letter->x - letter->offset->x);
HXDLIN( 424)												Float _hx_tmp30 = (_hx_tmp29 + letter->get_width());
HXDLIN( 424)												if ((_hx_tmp30 <= this->pointerX())) {
HXLINE( 424)													this->hexTypeNum++;
            												}
            												else {
HXLINE( 425)													goto _hx_goto_4;
            												}
            											}
            											_hx_goto_4:;
            										}
HXLINE( 427)										if ((this->hexTypeNum > 5)) {
HXLINE( 427)											this->hexTypeNum = 5;
            										}
HXLINE( 428)										this->hexTypeLine->set_visible(true);
HXLINE( 429)										this->centerHexTypeLine();
            									}
            									else {
HXLINE( 431)										this->holdingOnObj = null();
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 434)		if (::hx::IsNotNull( this->holdingOnObj )) {
HXLINE( 436)			bool _hx_tmp31;
HXDLIN( 436)			if ((::flixel::FlxG_obj::mouse->_leftButton->current != -1)) {
HXLINE( 436)				if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 436)					_hx_tmp31 = ::backend::Controls_obj::instance->justReleased(HX_("accept",08,93,06,0b));
            				}
            				else {
HXLINE( 436)					_hx_tmp31 = false;
            				}
            			}
            			else {
HXLINE( 436)				_hx_tmp31 = true;
            			}
HXDLIN( 436)			if (_hx_tmp31) {
HXLINE( 438)				this->holdingOnObj = null();
HXLINE( 439)				this->_storedColor = this->getShaderColor();
HXLINE( 440)				this->updateColors(null());
HXLINE( 441)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp32 = ::flixel::FlxG_obj::sound;
HXDLIN( 441)				_hx_tmp32->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            			}
            			else {
HXLINE( 443)				bool _hx_tmp33;
HXDLIN( 443)				if (!(generalMoved)) {
HXLINE( 443)					_hx_tmp33 = generalPressed;
            				}
            				else {
HXLINE( 443)					_hx_tmp33 = true;
            				}
HXDLIN( 443)				if (_hx_tmp33) {
HXLINE( 445)					if (::hx::IsInstanceEq( this->holdingOnObj,this->colorGradient )) {
HXLINE( 447)						Float Value = this->pointerY();
HXDLIN( 447)						Float Value1 = (Value - this->colorGradient->y);
HXDLIN( 447)						Float Value2 = (Value1 / this->colorGradient->get_height());
HXDLIN( 447)						Float lowerBound;
HXDLIN( 447)						if ((Value2 < 0)) {
HXLINE( 447)							lowerBound = ( (Float)(0) );
            						}
            						else {
HXLINE( 447)							lowerBound = Value2;
            						}
HXDLIN( 447)						Float newBrightness;
HXDLIN( 447)						if ((lowerBound > 1)) {
HXLINE( 447)							newBrightness = ( (Float)(1) );
            						}
            						else {
HXLINE( 447)							newBrightness = lowerBound;
            						}
HXDLIN( 447)						Float newBrightness1 = (( (Float)(1) ) - newBrightness);
HXLINE( 448)						{
HXLINE( 448)							 ::options::NotesSubState _hx_tmp34 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 448)							_hx_tmp34->_storedColor = (_hx_tmp34->_storedColor & 16777215);
HXDLIN( 448)							 ::options::NotesSubState _hx_tmp35 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 448)							_hx_tmp35->_storedColor = (_hx_tmp35->_storedColor | 16777216);
            						}
HXLINE( 449)						int this2 = this->_storedColor;
HXDLIN( 449)						if ((::Math_obj::max((( (Float)(((this2 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this2 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this2 & 255)) ) / ( (Float)(255) )))) == 0)) {
HXLINE( 450)							Float Alpha = ( (Float)(1) );
HXDLIN( 450)							int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 450)							{
HXLINE( 450)								int Value3 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 450)								color = (color & -16711681);
HXDLIN( 450)								int color1;
HXDLIN( 450)								if ((Value3 > 255)) {
HXLINE( 450)									color1 = 255;
            								}
            								else {
HXLINE( 450)									if ((Value3 < 0)) {
HXLINE( 450)										color1 = 0;
            									}
            									else {
HXLINE( 450)										color1 = Value3;
            									}
            								}
HXDLIN( 450)								color = (color | (color1 << 16));
            							}
HXDLIN( 450)							{
HXLINE( 450)								int Value4 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 450)								color = (color & -65281);
HXDLIN( 450)								int color2;
HXDLIN( 450)								if ((Value4 > 255)) {
HXLINE( 450)									color2 = 255;
            								}
            								else {
HXLINE( 450)									if ((Value4 < 0)) {
HXLINE( 450)										color2 = 0;
            									}
            									else {
HXLINE( 450)										color2 = Value4;
            									}
            								}
HXDLIN( 450)								color = (color | (color2 << 8));
            							}
HXDLIN( 450)							{
HXLINE( 450)								int Value5 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 450)								color = (color & -256);
HXDLIN( 450)								int color3;
HXDLIN( 450)								if ((Value5 > 255)) {
HXLINE( 450)									color3 = 255;
            								}
            								else {
HXLINE( 450)									if ((Value5 < 0)) {
HXLINE( 450)										color3 = 0;
            									}
            									else {
HXLINE( 450)										color3 = Value5;
            									}
            								}
HXDLIN( 450)								color = (color | color3);
            							}
HXDLIN( 450)							{
HXLINE( 450)								int Value6 = ::Math_obj::round((Alpha * ( (Float)(255) )));
HXDLIN( 450)								color = (color & 16777215);
HXDLIN( 450)								int color4;
HXDLIN( 450)								if ((Value6 > 255)) {
HXLINE( 450)									color4 = 255;
            								}
            								else {
HXLINE( 450)									if ((Value6 < 0)) {
HXLINE( 450)										color4 = 0;
            									}
            									else {
HXLINE( 450)										color4 = Value6;
            									}
            								}
HXDLIN( 450)								color = (color | (color4 << 24));
            							}
HXDLIN( 450)							this->setShaderColor(color);
            						}
            						else {
HXLINE( 452)							Float _hx_tmp36 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::get_hue(this->_storedColor);
HXDLIN( 452)							int this3 = this->_storedColor;
HXDLIN( 452)							this->setShaderColor(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(_hx_tmp36,((::Math_obj::max((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this3 & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this3 & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this3 & 255)) ) / ( (Float)(255) ))))),newBrightness1,null()));
            						}
HXLINE( 453)						this->updateColors(this->_storedColor);
            					}
            					else {
HXLINE( 455)						if (::hx::IsInstanceEq( this->holdingOnObj,this->colorWheel )) {
HXLINE( 457)							Float x = this->colorWheel->x;
HXDLIN( 457)							Float x1 = (x + (this->colorWheel->get_width() / ( (Float)(2) )));
HXDLIN( 457)							Float y = this->colorWheel->y;
HXDLIN( 457)							Float y1 = (y + (this->colorWheel->get_height() / ( (Float)(2) )));
HXDLIN( 457)							 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x1,y1);
HXDLIN( 457)							point->_inPool = false;
HXDLIN( 457)							 ::flixel::math::FlxBasePoint center = point;
HXLINE( 458)							 ::flixel::math::FlxBasePoint mouse = this->pointerFlxPoint();
HXLINE( 459)							Float x2 = (center->x - mouse->x);
HXDLIN( 459)							Float y2 = (center->y - mouse->y);
HXDLIN( 459)							Float hue = ( (Float)(::flixel::math::FlxMath_obj::wrap((::flixel::math::FlxMath_obj::wrap(::Std_obj::_hx_int((::Math_obj::atan2(y2,x2) * (( (Float)(180) ) / ::Math_obj::PI))),0,360) - 90),0,360)) );
HXLINE( 460)							Float dx = (center->x - mouse->x);
HXDLIN( 460)							Float dy = (center->y - mouse->y);
HXDLIN( 460)							if (center->_weak) {
HXLINE( 460)								center->put();
            							}
HXDLIN( 460)							Float Value7 = ::Math_obj::sqrt(((dx * dx) + (dy * dy)));
HXDLIN( 460)							Float Value8 = ((Value7 / this->colorWheel->get_width()) * ( (Float)(2) ));
HXDLIN( 460)							Float lowerBound1;
HXDLIN( 460)							if ((Value8 < 0)) {
HXLINE( 460)								lowerBound1 = ( (Float)(0) );
            							}
            							else {
HXLINE( 460)								lowerBound1 = Value8;
            							}
HXDLIN( 460)							Float sat;
HXDLIN( 460)							if ((lowerBound1 > 1)) {
HXLINE( 460)								sat = ( (Float)(1) );
            							}
            							else {
HXLINE( 460)								sat = lowerBound1;
            							}
HXLINE( 462)							if ((sat != 0)) {
HXLINE( 462)								int this4 = this->_storedColor;
HXDLIN( 462)								this->setShaderColor(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(hue,sat,::Math_obj::max((( (Float)(((this4 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this4 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this4 & 255)) ) / ( (Float)(255) )))),null()));
            							}
            							else {
HXLINE( 463)								int this5 = this->_storedColor;
HXDLIN( 463)								Float Red = ::Math_obj::max((( (Float)(((this5 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this5 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this5 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 463)								int this6 = this->_storedColor;
HXDLIN( 463)								Float Green = ::Math_obj::max((( (Float)(((this6 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this6 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this6 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 463)								int this7 = this->_storedColor;
HXDLIN( 463)								Float Blue = ::Math_obj::max((( (Float)(((this7 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this7 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this7 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 463)								Float Alpha1 = ( (Float)(1) );
HXDLIN( 463)								int color5 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 463)								{
HXLINE( 463)									int Value9 = ::Math_obj::round((Red * ( (Float)(255) )));
HXDLIN( 463)									color5 = (color5 & -16711681);
HXDLIN( 463)									int color6;
HXDLIN( 463)									if ((Value9 > 255)) {
HXLINE( 463)										color6 = 255;
            									}
            									else {
HXLINE( 463)										if ((Value9 < 0)) {
HXLINE( 463)											color6 = 0;
            										}
            										else {
HXLINE( 463)											color6 = Value9;
            										}
            									}
HXDLIN( 463)									color5 = (color5 | (color6 << 16));
            								}
HXDLIN( 463)								{
HXLINE( 463)									int Value10 = ::Math_obj::round((Green * ( (Float)(255) )));
HXDLIN( 463)									color5 = (color5 & -65281);
HXDLIN( 463)									int color7;
HXDLIN( 463)									if ((Value10 > 255)) {
HXLINE( 463)										color7 = 255;
            									}
            									else {
HXLINE( 463)										if ((Value10 < 0)) {
HXLINE( 463)											color7 = 0;
            										}
            										else {
HXLINE( 463)											color7 = Value10;
            										}
            									}
HXDLIN( 463)									color5 = (color5 | (color7 << 8));
            								}
HXDLIN( 463)								{
HXLINE( 463)									int Value11 = ::Math_obj::round((Blue * ( (Float)(255) )));
HXDLIN( 463)									color5 = (color5 & -256);
HXDLIN( 463)									int color8;
HXDLIN( 463)									if ((Value11 > 255)) {
HXLINE( 463)										color8 = 255;
            									}
            									else {
HXLINE( 463)										if ((Value11 < 0)) {
HXLINE( 463)											color8 = 0;
            										}
            										else {
HXLINE( 463)											color8 = Value11;
            										}
            									}
HXDLIN( 463)									color5 = (color5 | color8);
            								}
HXDLIN( 463)								{
HXLINE( 463)									int Value12 = ::Math_obj::round((Alpha1 * ( (Float)(255) )));
HXDLIN( 463)									color5 = (color5 & 16777215);
HXDLIN( 463)									int color9;
HXDLIN( 463)									if ((Value12 > 255)) {
HXLINE( 463)										color9 = 255;
            									}
            									else {
HXLINE( 463)										if ((Value12 < 0)) {
HXLINE( 463)											color9 = 0;
            										}
            										else {
HXLINE( 463)											color9 = Value12;
            										}
            									}
HXDLIN( 463)									color5 = (color5 | (color9 << 24));
            								}
HXDLIN( 463)								this->setShaderColor(color5);
            							}
HXLINE( 464)							this->updateColors(null());
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE( 468)			bool _hx_tmp37;
HXDLIN( 468)			if (::backend::Controls_obj::instance->get_RESET()) {
HXLINE( 468)				_hx_tmp37 = (this->hexTypeNum < 0);
            			}
            			else {
HXLINE( 468)				_hx_tmp37 = false;
            			}
HXDLIN( 468)			if (_hx_tmp37) {
HXLINE( 470)				bool _hx_tmp38;
HXDLIN( 470)				 ::flixel::input::keyboard::FlxKeyList _this7 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 470)				if (!(_this7->keyManager->checkStatusUnsafe(16,_this7->status))) {
HXLINE( 470)					_hx_tmp38 = ::flixel::FlxG_obj::gamepads->anyHasState(4,2);
            				}
            				else {
HXLINE( 470)					_hx_tmp38 = true;
            				}
HXDLIN( 470)				if (_hx_tmp38) {
HXLINE( 472)					int _g4 = 0;
HXDLIN( 472)					while((_g4 < 3)){
HXLINE( 472)						_g4 = (_g4 + 1);
HXDLIN( 472)						int i = (_g4 - 1);
HXLINE( 474)						 ::shaders::RGBShaderReference strumRGB = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 475)						int color10;
HXDLIN( 475)						if (!(this->onPixel)) {
HXLINE( 475)							color10 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(i);
            						}
            						else {
HXLINE( 475)							color10 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(i);
            						}
HXLINE( 477)						switch((int)(i)){
            							case (int)0: {
HXLINE( 480)								 ::shaders::RGBPalette _hx_tmp39 = this->getShader();
HXDLIN( 480)								_hx_tmp39->set_r(strumRGB->set_r(color10));
            							}
            							break;
            							case (int)1: {
HXLINE( 482)								 ::shaders::RGBPalette _hx_tmp40 = this->getShader();
HXDLIN( 482)								_hx_tmp40->set_g(strumRGB->set_g(color10));
            							}
            							break;
            							case (int)2: {
HXLINE( 484)								 ::shaders::RGBPalette _hx_tmp41 = this->getShader();
HXDLIN( 484)								_hx_tmp41->set_b(strumRGB->set_b(color10));
            							}
            							break;
            						}
HXLINE( 486)						this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[i] = color10;
            					}
            				}
HXLINE( 489)				int _hx_tmp42;
HXDLIN( 489)				if (!(this->onPixel)) {
HXLINE( 489)					_hx_tmp42 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            				}
            				else {
HXLINE( 489)					_hx_tmp42 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            				}
HXDLIN( 489)				this->setShaderColor(_hx_tmp42);
HXLINE( 490)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp43 = ::flixel::FlxG_obj::sound;
HXDLIN( 490)				_hx_tmp43->play(::backend::Paths_obj::sound(HX_("cancelMenu",39,a4,43,b7),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 491)				this->updateColors(null());
            			}
            		}
            	}


bool NotesSubState_obj::pointerOverlaps( ::Dynamic obj){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_496_pointerOverlaps)
HXLINE( 497)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 497)			return ::flixel::FlxG_obj::mouse->overlaps(( ( ::flixel::FlxBasic)(obj) ),null());
            		}
HXLINE( 498)		return ::flixel::FlxG_obj::overlap(this->controllerPointer,( ( ::flixel::FlxBasic)(obj) ),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,pointerOverlaps,return )

Float NotesSubState_obj::pointerX(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_502_pointerX)
HXLINE( 503)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 503)			return ( (Float)(::flixel::FlxG_obj::mouse->x) );
            		}
HXLINE( 504)		return this->controllerPointer->x;
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,pointerX,return )

Float NotesSubState_obj::pointerY(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_507_pointerY)
HXLINE( 508)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 508)			return ( (Float)(::flixel::FlxG_obj::mouse->y) );
            		}
HXLINE( 509)		return this->controllerPointer->y;
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,pointerY,return )

 ::flixel::math::FlxBasePoint NotesSubState_obj::pointerFlxPoint(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_512_pointerFlxPoint)
HXLINE( 513)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 513)			return ::flixel::FlxG_obj::mouse->getScreenPosition(null(),null());
            		}
HXLINE( 514)		return this->controllerPointer->getScreenPosition(null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,pointerFlxPoint,return )

void NotesSubState_obj::centerHexTypeLine(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_518_centerHexTypeLine)
HXLINE( 520)		if ((this->hexTypeNum > 0)) {
HXLINE( 522)			 ::objects::AlphaCharacter letter = this->alphabetHex->letters->__get((this->hexTypeNum - 1)).StaticCast<  ::objects::AlphaCharacter >();
HXLINE( 523)			 ::flixel::FlxSprite _hx_tmp = this->hexTypeLine;
HXDLIN( 523)			Float _hx_tmp1 = (letter->x - letter->offset->x);
HXDLIN( 523)			_hx_tmp->set_x((_hx_tmp1 + letter->get_width()));
            		}
            		else {
HXLINE( 527)			 ::objects::AlphaCharacter letter1 = this->alphabetHex->letters->__get(0).StaticCast<  ::objects::AlphaCharacter >();
HXLINE( 528)			this->hexTypeLine->set_x((letter1->x - letter1->offset->x));
            		}
HXLINE( 530)		 ::flixel::FlxSprite fh = this->hexTypeLine;
HXDLIN( 530)		Float fh1 = fh->x;
HXDLIN( 530)		fh->set_x((fh1 + this->hexTypeLine->get_width()));
HXLINE( 531)		this->hexTypeVisibleTimer = ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,centerHexTypeLine,(void))

void NotesSubState_obj::changeSelectionMode(::hx::Null< int >  __o_change){
            		int change = __o_change.Default(0);
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_534_changeSelectionMode)
HXLINE( 535)		 ::options::NotesSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 535)		_hx_tmp->curSelectedMode = (_hx_tmp->curSelectedMode + change);
HXLINE( 536)		if ((this->curSelectedMode < 0)) {
HXLINE( 537)			this->curSelectedMode = 2;
            		}
HXLINE( 538)		if ((this->curSelectedMode >= 3)) {
HXLINE( 539)			this->curSelectedMode = 0;
            		}
HXLINE( 541)		this->modeBG->set_visible(true);
HXLINE( 542)		this->notesBG->set_visible(false);
HXLINE( 543)		this->updateNotes(null());
HXLINE( 544)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 544)		_hx_tmp1->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,changeSelectionMode,(void))

void NotesSubState_obj::changeSelectionNote(::hx::Null< int >  __o_change){
            		int change = __o_change.Default(0);
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_546_changeSelectionNote)
HXLINE( 547)		 ::options::NotesSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 547)		_hx_tmp->curSelectedNote = (_hx_tmp->curSelectedNote + change);
HXLINE( 548)		if ((this->curSelectedNote < 0)) {
HXLINE( 549)			this->curSelectedNote = (this->dataArray->length - 1);
            		}
HXLINE( 550)		if ((this->curSelectedNote >= this->dataArray->length)) {
HXLINE( 551)			this->curSelectedNote = 0;
            		}
HXLINE( 553)		this->modeBG->set_visible(false);
HXLINE( 554)		this->notesBG->set_visible(true);
HXLINE( 555)		this->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 556)		this->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 557)		this->updateNotes(null());
HXLINE( 558)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 558)		_hx_tmp1->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,changeSelectionNote,(void))

 ::objects::Alphabet NotesSubState_obj::makeColorAlphabet(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y){
            		Float x = __o_x.Default(0);
            		Float y = __o_y.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_563_makeColorAlphabet)
HXLINE( 564)		 ::objects::Alphabet text =  ::objects::Alphabet_obj::__alloc( HX_CTX ,x,y,HX_("",00,00,00,00),true);
HXLINE( 565)		text->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE( 566)		text->setScale(((Float)0.6),null());
HXLINE( 567)		this->add(text);
HXLINE( 568)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC2(NotesSubState_obj,makeColorAlphabet,return )

void NotesSubState_obj::spawnNotes(){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		void _hx_run( ::flixel::FlxSprite note){
            			HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_582_spawnNotes)
HXLINE( 583)			note->kill();
HXLINE( 584)			note->destroy();
            		}
            		HX_END_LOCAL_FUNC1((void))

            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            		void _hx_run( ::objects::StrumNote note){
            			HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_586_spawnNotes)
HXLINE( 587)			note->kill();
HXLINE( 588)			note->destroy();
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_577_spawnNotes)
HXLINE( 578)		::Array< ::Dynamic> _hx_tmp;
HXDLIN( 578)		if (!(this->onPixel)) {
HXLINE( 578)			_hx_tmp = ::backend::ClientPrefs_obj::data->arrowRGB;
            		}
            		else {
HXLINE( 578)			_hx_tmp = ::backend::ClientPrefs_obj::data->arrowRGBPixel;
            		}
HXDLIN( 578)		this->dataArray = _hx_tmp;
HXLINE( 579)		if (this->onPixel) {
HXLINE( 579)			::states::PlayState_obj::stageUI = HX_("pixel",86,c6,a3,c2);
            		}
HXLINE( 582)		this->modeNotes->forEachAlive( ::Dynamic(new _hx_Closure_0()),null());
HXLINE( 586)		this->myNotes->forEachAlive( ::Dynamic(new _hx_Closure_1()),null());
HXLINE( 590)		this->modeNotes->clear();
HXLINE( 591)		this->myNotes->clear();
HXLINE( 593)		if (::hx::IsNotNull( this->skinNote )) {
HXLINE( 595)			this->remove(this->skinNote,null());
HXLINE( 596)			this->skinNote->destroy();
            		}
HXLINE( 598)		if (::hx::IsNotNull( this->bigNote )) {
HXLINE( 600)			this->remove(this->bigNote,null());
HXLINE( 601)			this->bigNote->destroy();
            		}
HXLINE( 605)		int res;
HXDLIN( 605)		if (this->onPixel) {
HXLINE( 605)			res = 160;
            		}
            		else {
HXLINE( 605)			res = 17;
            		}
HXLINE( 606)		 ::flixel::FlxSprite _hx_tmp1 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,48,24,null());
HXDLIN( 606)		::String _hx_tmp2;
HXDLIN( 606)		if (this->onPixel) {
HXLINE( 606)			_hx_tmp2 = HX_("note",f2,17,0a,49);
            		}
            		else {
HXLINE( 606)			_hx_tmp2 = HX_("notePixel",34,11,31,00);
            		}
HXDLIN( 606)		this->skinNote = _hx_tmp1->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + _hx_tmp2),null(),null()),true,res,res,null(),null());
HXLINE( 607)		this->skinNote->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 608)		this->skinNote->setGraphicSize(68,null());
HXLINE( 609)		this->skinNote->updateHitbox();
HXLINE( 610)		this->skinNote->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_0afa74a2_23,1),24,true,null(),null());
HXLINE( 611)		this->skinNote->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 612)		if (!(this->onPixel)) {
HXLINE( 612)			this->skinNote->set_antialiasing(false);
            		}
HXLINE( 613)		this->add(this->skinNote);
HXLINE( 615)		int res1;
HXDLIN( 615)		if (!(this->onPixel)) {
HXLINE( 615)			res1 = 160;
            		}
            		else {
HXLINE( 615)			res1 = 17;
            		}
HXLINE( 616)		{
HXLINE( 616)			int _g = 0;
HXDLIN( 616)			while((_g < 3)){
HXLINE( 616)				_g = (_g + 1);
HXDLIN( 616)				int i = (_g - 1);
HXLINE( 618)				 ::flixel::FlxSprite newNote =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,(230 + (100 * i)),100,null());
HXDLIN( 618)				::String newNote1;
HXDLIN( 618)				if (!(this->onPixel)) {
HXLINE( 618)					newNote1 = HX_("note",f2,17,0a,49);
            				}
            				else {
HXLINE( 618)					newNote1 = HX_("notePixel",34,11,31,00);
            				}
HXDLIN( 618)				 ::flixel::FlxSprite newNote2 = newNote->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + newNote1),null(),null()),true,res1,res1,null(),null());
HXLINE( 619)				newNote2->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 620)				newNote2->setGraphicSize(85,null());
HXLINE( 621)				newNote2->updateHitbox();
HXLINE( 622)				newNote2->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::__new(1)->init(0,i),24,true,null(),null());
HXLINE( 623)				newNote2->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 624)				newNote2->ID = i;
HXLINE( 625)				if (this->onPixel) {
HXLINE( 625)					newNote2->set_antialiasing(false);
            				}
HXLINE( 626)				this->modeNotes->add(newNote2).StaticCast<  ::flixel::FlxSprite >();
            			}
            		}
HXLINE( 629)		::objects::Note_obj::globalRgbShaders = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 630)		{
HXLINE( 630)			int _g1 = 0;
HXDLIN( 630)			int _g2 = this->dataArray->length;
HXDLIN( 630)			while((_g1 < _g2)){
HXLINE( 630)				_g1 = (_g1 + 1);
HXDLIN( 630)				int i1 = (_g1 - 1);
HXLINE( 632)				::objects::Note_obj::initializeGlobalRGBShader(i1);
HXLINE( 633)				 ::objects::StrumNote newNote3 =  ::objects::StrumNote_obj::__alloc( HX_CTX ,(150 + ((( (Float)(480) ) / ( (Float)(this->dataArray->length) )) * ( (Float)(i1) ))),( (Float)(200) ),i1,0);
HXLINE( 634)				newNote3->useRGBShader = true;
HXLINE( 635)				newNote3->setGraphicSize(102,null());
HXLINE( 636)				newNote3->updateHitbox();
HXLINE( 637)				newNote3->ID = i1;
HXLINE( 638)				this->myNotes->add(newNote3).StaticCast<  ::objects::StrumNote >();
            			}
            		}
HXLINE( 641)		this->bigNote =  ::objects::Note_obj::__alloc( HX_CTX ,( (Float)(0) ),0,null(),false,true,null());
HXLINE( 642)		this->bigNote->setPosition(250,325);
HXLINE( 643)		this->bigNote->setGraphicSize(250,null());
HXLINE( 644)		this->bigNote->updateHitbox();
HXLINE( 645)		this->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 646)		this->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 647)		{
HXLINE( 647)			int _g3 = 0;
HXDLIN( 647)			int _g4 = ::objects::Note_obj::colArray->length;
HXDLIN( 647)			while((_g3 < _g4)){
HXLINE( 647)				_g3 = (_g3 + 1);
HXDLIN( 647)				int i2 = (_g3 - 1);
HXLINE( 649)				if (!(this->onPixel)) {
HXLINE( 649)					this->bigNote->animation->addByPrefix((HX_("note",f2,17,0a,49) + i2),(::objects::Note_obj::colArray->__get(i2) + HX_("0",30,00,00,00)),24,true,null(),null());
            				}
            				else {
HXLINE( 650)					this->bigNote->animation->add((HX_("note",f2,17,0a,49) + i2),::Array_obj< int >::__new(1)->init(0,(i2 + 4)),24,true,null(),null());
            				}
            			}
            		}
HXLINE( 652)		int _hx_tmp3 = (this->members->indexOf(this->myNotes,null()) + 1);
HXDLIN( 652)		this->insert(_hx_tmp3,this->bigNote);
HXLINE( 653)		this->_storedColor = this->getShaderColor();
HXLINE( 654)		::states::PlayState_obj::stageUI = HX_("normal",27,72,69,30);
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,spawnNotes,(void))

void NotesSubState_obj::updateNotes( ::Dynamic __o_instant){
            		 ::Dynamic instant = __o_instant;
            		if (::hx::IsNull(__o_instant)) instant = false;
            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_658_updateNotes)
HXLINE( 659)		{
HXLINE( 659)			 ::Dynamic filter = null();
HXDLIN( 659)			 ::flixel::group::FlxTypedGroupIterator note =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->modeNotes->members,filter);
HXDLIN( 659)			while(note->hasNext()){
HXLINE( 659)				 ::flixel::FlxSprite note1 = note->next().StaticCast<  ::flixel::FlxSprite >();
HXLINE( 660)				Float _hx_tmp;
HXDLIN( 660)				if ((this->curSelectedMode == note1->ID)) {
HXLINE( 660)					_hx_tmp = ( (Float)(1) );
            				}
            				else {
HXLINE( 660)					_hx_tmp = ((Float)0.6);
            				}
HXDLIN( 660)				note1->set_alpha(_hx_tmp);
            			}
            		}
HXLINE( 662)		{
HXLINE( 662)			 ::Dynamic filter1 = null();
HXDLIN( 662)			 ::flixel::group::FlxTypedGroupIterator note2 =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->myNotes->members,filter1);
HXDLIN( 662)			while(note2->hasNext()){
HXLINE( 662)				 ::objects::StrumNote note3 = note2->next().StaticCast<  ::objects::StrumNote >();
HXLINE( 664)				::String newAnim;
HXDLIN( 664)				if ((this->curSelectedNote == note3->ID)) {
HXLINE( 664)					newAnim = HX_("confirm",00,9d,39,10);
            				}
            				else {
HXLINE( 664)					newAnim = HX_("pressed",a2,d2,e6,39);
            				}
HXLINE( 665)				Float _hx_tmp1;
HXDLIN( 665)				if ((this->curSelectedNote == note3->ID)) {
HXLINE( 665)					_hx_tmp1 = ( (Float)(1) );
            				}
            				else {
HXLINE( 665)					_hx_tmp1 = ((Float)0.6);
            				}
HXDLIN( 665)				note3->set_alpha(_hx_tmp1);
HXLINE( 666)				bool _hx_tmp2;
HXDLIN( 666)				if (::hx::IsNotNull( note3->animation->_curAnim )) {
HXLINE( 666)					_hx_tmp2 = (note3->animation->_curAnim->name != newAnim);
            				}
            				else {
HXLINE( 666)					_hx_tmp2 = true;
            				}
HXDLIN( 666)				if (_hx_tmp2) {
HXLINE( 666)					note3->playAnim(newAnim,true);
            				}
HXLINE( 667)				if (( (bool)(instant) )) {
HXLINE( 667)					note3->animation->_curAnim->finish();
            				}
            			}
            		}
HXLINE( 669)		this->bigNote->animation->play((HX_("note",f2,17,0a,49) + this->curSelectedNote),true,null(),null());
HXLINE( 670)		this->updateColors(null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,updateNotes,(void))

void NotesSubState_obj::updateColors( ::Dynamic specific){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_674_updateColors)
HXLINE( 675)		int color = this->getShaderColor();
HXLINE( 676)		int wheelColor;
HXDLIN( 676)		if (::hx::IsNull( specific )) {
HXLINE( 676)			wheelColor = this->getShaderColor();
            		}
            		else {
HXLINE( 676)			wheelColor = ( (int)(specific) );
            		}
HXLINE( 677)		 ::objects::Alphabet _hx_tmp = this->alphabetR;
HXDLIN( 677)		_hx_tmp->set_text(::Std_obj::string(((color >> 16) & 255)));
HXLINE( 678)		 ::objects::Alphabet _hx_tmp1 = this->alphabetG;
HXDLIN( 678)		_hx_tmp1->set_text(::Std_obj::string(((color >> 8) & 255)));
HXLINE( 679)		 ::objects::Alphabet _hx_tmp2 = this->alphabetB;
HXDLIN( 679)		_hx_tmp2->set_text(::Std_obj::string((color & 255)));
HXLINE( 680)		 ::objects::Alphabet _hx_tmp3 = this->alphabetHex;
HXDLIN( 680)		::String _hx_tmp4 = (HX_("",00,00,00,00) + ::StringTools_obj::hex(((color >> 16) & 255),2));
HXDLIN( 680)		::String _hx_tmp5 = (_hx_tmp4 + ::StringTools_obj::hex(((color >> 8) & 255),2));
HXDLIN( 680)		_hx_tmp3->set_text((_hx_tmp5 + ::StringTools_obj::hex((color & 255),2)));
HXLINE( 681)		{
HXLINE( 681)			int _g = 0;
HXDLIN( 681)			::Array< ::Dynamic> _g1 = this->alphabetHex->letters;
HXDLIN( 681)			while((_g < _g1->length)){
HXLINE( 681)				 ::objects::AlphaCharacter letter = _g1->__get(_g).StaticCast<  ::objects::AlphaCharacter >();
HXDLIN( 681)				_g = (_g + 1);
HXDLIN( 681)				letter->set_color(color);
            			}
            		}
HXLINE( 683)		 ::flixel::FlxSprite _hx_tmp6 = this->colorWheel;
HXDLIN( 683)		_hx_tmp6->set_color(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(( (Float)(0) ),( (Float)(0) ),::Math_obj::max((( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((color & 255)) ) / ( (Float)(255) )))),null()));
HXLINE( 684)		 ::flixel::FlxSprite _hx_tmp7 = this->colorWheelSelector;
HXDLIN( 684)		Float _hx_tmp8 = this->colorWheel->x;
HXDLIN( 684)		Float _hx_tmp9 = (_hx_tmp8 + (this->colorWheel->get_width() / ( (Float)(2) )));
HXDLIN( 684)		Float _hx_tmp10 = this->colorWheel->y;
HXDLIN( 684)		_hx_tmp7->setPosition(_hx_tmp9,(_hx_tmp10 + (this->colorWheel->get_height() / ( (Float)(2) ))));
HXLINE( 685)		if ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) != 0)) {
HXLINE( 687)			Float hueWrap = ::flixel::util::_FlxColor::FlxColor_Impl__obj::get_hue(wheelColor);
HXDLIN( 687)			Float hueWrap1 = ((hueWrap * ::Math_obj::PI) / ( (Float)(180) ));
HXLINE( 688)			 ::flixel::FlxSprite fh = this->colorWheelSelector;
HXDLIN( 688)			Float fh1 = fh->x;
HXDLIN( 688)			Float _hx_tmp11 = ::Math_obj::sin(hueWrap1);
HXDLIN( 688)			Float _hx_tmp12 = ((_hx_tmp11 * this->colorWheel->get_width()) / ( (Float)(2) ));
HXDLIN( 688)			fh->set_x((fh1 + (_hx_tmp12 * ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))))));
HXLINE( 689)			 ::flixel::FlxSprite fh2 = this->colorWheelSelector;
HXDLIN( 689)			Float fh3 = fh2->y;
HXDLIN( 689)			Float _hx_tmp13 = ::Math_obj::cos(hueWrap1);
HXDLIN( 689)			Float _hx_tmp14 = ((_hx_tmp13 * this->colorWheel->get_height()) / ( (Float)(2) ));
HXDLIN( 689)			fh2->set_y((fh3 - (_hx_tmp14 * ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))))));
            		}
HXLINE( 691)		 ::flixel::FlxSprite _hx_tmp15 = this->colorGradientSelector;
HXDLIN( 691)		Float _hx_tmp16 = this->colorGradient->y;
HXDLIN( 691)		Float _hx_tmp17 = this->colorGradient->get_height();
HXDLIN( 691)		_hx_tmp15->set_y((_hx_tmp16 + (_hx_tmp17 * (( (Float)(1) ) - ::Math_obj::max((( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((color & 255)) ) / ( (Float)(255) ))))))));
HXLINE( 693)		 ::shaders::RGBShaderReference strumRGB = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 694)		switch((int)(this->curSelectedMode)){
            			case (int)0: {
HXLINE( 697)				 ::shaders::RGBPalette _hx_tmp18 = this->getShader();
HXDLIN( 697)				_hx_tmp18->set_r(strumRGB->set_r(color));
            			}
            			break;
            			case (int)1: {
HXLINE( 699)				 ::shaders::RGBPalette _hx_tmp19 = this->getShader();
HXDLIN( 699)				_hx_tmp19->set_g(strumRGB->set_g(color));
            			}
            			break;
            			case (int)2: {
HXLINE( 701)				 ::shaders::RGBPalette _hx_tmp20 = this->getShader();
HXDLIN( 701)				_hx_tmp20->set_b(strumRGB->set_b(color));
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,updateColors,(void))

void NotesSubState_obj::setShaderColor(int value){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_705_setShaderColor)
HXDLIN( 705)		this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[this->curSelectedMode] = value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,setShaderColor,(void))

int NotesSubState_obj::getShaderColor(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_706_getShaderColor)
HXDLIN( 706)		return this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,getShaderColor,return )

 ::shaders::RGBPalette NotesSubState_obj::getShader(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_707_getShader)
HXDLIN( 707)		return ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,getShader,return )


::hx::ObjectPtr< NotesSubState_obj > NotesSubState_obj::__new() {
	::hx::ObjectPtr< NotesSubState_obj > __this = new NotesSubState_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< NotesSubState_obj > NotesSubState_obj::__alloc(::hx::Ctx *_hx_ctx) {
	NotesSubState_obj *__this = (NotesSubState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(NotesSubState_obj), true, "options.NotesSubState"));
	*(void **)__this = NotesSubState_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

NotesSubState_obj::NotesSubState_obj()
{
}

void NotesSubState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(NotesSubState);
	HX_MARK_MEMBER_NAME(onModeColumn,"onModeColumn");
	HX_MARK_MEMBER_NAME(curSelectedMode,"curSelectedMode");
	HX_MARK_MEMBER_NAME(curSelectedNote,"curSelectedNote");
	HX_MARK_MEMBER_NAME(onPixel,"onPixel");
	HX_MARK_MEMBER_NAME(dataArray,"dataArray");
	HX_MARK_MEMBER_NAME(hexTypeLine,"hexTypeLine");
	HX_MARK_MEMBER_NAME(hexTypeNum,"hexTypeNum");
	HX_MARK_MEMBER_NAME(hexTypeVisibleTimer,"hexTypeVisibleTimer");
	HX_MARK_MEMBER_NAME(copyButton,"copyButton");
	HX_MARK_MEMBER_NAME(pasteButton,"pasteButton");
	HX_MARK_MEMBER_NAME(colorGradient,"colorGradient");
	HX_MARK_MEMBER_NAME(colorGradientSelector,"colorGradientSelector");
	HX_MARK_MEMBER_NAME(colorPalette,"colorPalette");
	HX_MARK_MEMBER_NAME(colorWheel,"colorWheel");
	HX_MARK_MEMBER_NAME(colorWheelSelector,"colorWheelSelector");
	HX_MARK_MEMBER_NAME(alphabetR,"alphabetR");
	HX_MARK_MEMBER_NAME(alphabetG,"alphabetG");
	HX_MARK_MEMBER_NAME(alphabetB,"alphabetB");
	HX_MARK_MEMBER_NAME(alphabetHex,"alphabetHex");
	HX_MARK_MEMBER_NAME(modeBG,"modeBG");
	HX_MARK_MEMBER_NAME(notesBG,"notesBG");
	HX_MARK_MEMBER_NAME(controllerPointer,"controllerPointer");
	HX_MARK_MEMBER_NAME(_lastControllerMode,"_lastControllerMode");
	HX_MARK_MEMBER_NAME(tipTxt,"tipTxt");
	HX_MARK_MEMBER_NAME(_storedColor,"_storedColor");
	HX_MARK_MEMBER_NAME(changingNote,"changingNote");
	HX_MARK_MEMBER_NAME(holdingOnObj,"holdingOnObj");
	HX_MARK_MEMBER_NAME(allowedTypeKeys,"allowedTypeKeys");
	HX_MARK_MEMBER_NAME(skinNote,"skinNote");
	HX_MARK_MEMBER_NAME(modeNotes,"modeNotes");
	HX_MARK_MEMBER_NAME(myNotes,"myNotes");
	HX_MARK_MEMBER_NAME(bigNote,"bigNote");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void NotesSubState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(onModeColumn,"onModeColumn");
	HX_VISIT_MEMBER_NAME(curSelectedMode,"curSelectedMode");
	HX_VISIT_MEMBER_NAME(curSelectedNote,"curSelectedNote");
	HX_VISIT_MEMBER_NAME(onPixel,"onPixel");
	HX_VISIT_MEMBER_NAME(dataArray,"dataArray");
	HX_VISIT_MEMBER_NAME(hexTypeLine,"hexTypeLine");
	HX_VISIT_MEMBER_NAME(hexTypeNum,"hexTypeNum");
	HX_VISIT_MEMBER_NAME(hexTypeVisibleTimer,"hexTypeVisibleTimer");
	HX_VISIT_MEMBER_NAME(copyButton,"copyButton");
	HX_VISIT_MEMBER_NAME(pasteButton,"pasteButton");
	HX_VISIT_MEMBER_NAME(colorGradient,"colorGradient");
	HX_VISIT_MEMBER_NAME(colorGradientSelector,"colorGradientSelector");
	HX_VISIT_MEMBER_NAME(colorPalette,"colorPalette");
	HX_VISIT_MEMBER_NAME(colorWheel,"colorWheel");
	HX_VISIT_MEMBER_NAME(colorWheelSelector,"colorWheelSelector");
	HX_VISIT_MEMBER_NAME(alphabetR,"alphabetR");
	HX_VISIT_MEMBER_NAME(alphabetG,"alphabetG");
	HX_VISIT_MEMBER_NAME(alphabetB,"alphabetB");
	HX_VISIT_MEMBER_NAME(alphabetHex,"alphabetHex");
	HX_VISIT_MEMBER_NAME(modeBG,"modeBG");
	HX_VISIT_MEMBER_NAME(notesBG,"notesBG");
	HX_VISIT_MEMBER_NAME(controllerPointer,"controllerPointer");
	HX_VISIT_MEMBER_NAME(_lastControllerMode,"_lastControllerMode");
	HX_VISIT_MEMBER_NAME(tipTxt,"tipTxt");
	HX_VISIT_MEMBER_NAME(_storedColor,"_storedColor");
	HX_VISIT_MEMBER_NAME(changingNote,"changingNote");
	HX_VISIT_MEMBER_NAME(holdingOnObj,"holdingOnObj");
	HX_VISIT_MEMBER_NAME(allowedTypeKeys,"allowedTypeKeys");
	HX_VISIT_MEMBER_NAME(skinNote,"skinNote");
	HX_VISIT_MEMBER_NAME(modeNotes,"modeNotes");
	HX_VISIT_MEMBER_NAME(myNotes,"myNotes");
	HX_VISIT_MEMBER_NAME(bigNote,"bigNote");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val NotesSubState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"modeBG") ) { return ::hx::Val( modeBG ); }
		if (HX_FIELD_EQ(inName,"tipTxt") ) { return ::hx::Val( tipTxt ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onPixel") ) { return ::hx::Val( onPixel ); }
		if (HX_FIELD_EQ(inName,"notesBG") ) { return ::hx::Val( notesBG ); }
		if (HX_FIELD_EQ(inName,"myNotes") ) { return ::hx::Val( myNotes ); }
		if (HX_FIELD_EQ(inName,"bigNote") ) { return ::hx::Val( bigNote ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pointerX") ) { return ::hx::Val( pointerX_dyn() ); }
		if (HX_FIELD_EQ(inName,"pointerY") ) { return ::hx::Val( pointerY_dyn() ); }
		if (HX_FIELD_EQ(inName,"skinNote") ) { return ::hx::Val( skinNote ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"dataArray") ) { return ::hx::Val( dataArray ); }
		if (HX_FIELD_EQ(inName,"alphabetR") ) { return ::hx::Val( alphabetR ); }
		if (HX_FIELD_EQ(inName,"alphabetG") ) { return ::hx::Val( alphabetG ); }
		if (HX_FIELD_EQ(inName,"alphabetB") ) { return ::hx::Val( alphabetB ); }
		if (HX_FIELD_EQ(inName,"updateTip") ) { return ::hx::Val( updateTip_dyn() ); }
		if (HX_FIELD_EQ(inName,"modeNotes") ) { return ::hx::Val( modeNotes ); }
		if (HX_FIELD_EQ(inName,"getShader") ) { return ::hx::Val( getShader_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hexTypeNum") ) { return ::hx::Val( hexTypeNum ); }
		if (HX_FIELD_EQ(inName,"copyButton") ) { return ::hx::Val( copyButton ); }
		if (HX_FIELD_EQ(inName,"colorWheel") ) { return ::hx::Val( colorWheel ); }
		if (HX_FIELD_EQ(inName,"spawnNotes") ) { return ::hx::Val( spawnNotes_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"hexTypeLine") ) { return ::hx::Val( hexTypeLine ); }
		if (HX_FIELD_EQ(inName,"pasteButton") ) { return ::hx::Val( pasteButton ); }
		if (HX_FIELD_EQ(inName,"alphabetHex") ) { return ::hx::Val( alphabetHex ); }
		if (HX_FIELD_EQ(inName,"updateNotes") ) { return ::hx::Val( updateNotes_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"onModeColumn") ) { return ::hx::Val( onModeColumn ); }
		if (HX_FIELD_EQ(inName,"colorPalette") ) { return ::hx::Val( colorPalette ); }
		if (HX_FIELD_EQ(inName,"_storedColor") ) { return ::hx::Val( _storedColor ); }
		if (HX_FIELD_EQ(inName,"changingNote") ) { return ::hx::Val( changingNote ); }
		if (HX_FIELD_EQ(inName,"holdingOnObj") ) { return ::hx::Val( holdingOnObj ); }
		if (HX_FIELD_EQ(inName,"updateColors") ) { return ::hx::Val( updateColors_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"colorGradient") ) { return ::hx::Val( colorGradient ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setShaderColor") ) { return ::hx::Val( setShaderColor_dyn() ); }
		if (HX_FIELD_EQ(inName,"getShaderColor") ) { return ::hx::Val( getShaderColor_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curSelectedMode") ) { return ::hx::Val( curSelectedMode ); }
		if (HX_FIELD_EQ(inName,"curSelectedNote") ) { return ::hx::Val( curSelectedNote ); }
		if (HX_FIELD_EQ(inName,"allowedTypeKeys") ) { return ::hx::Val( allowedTypeKeys ); }
		if (HX_FIELD_EQ(inName,"pointerOverlaps") ) { return ::hx::Val( pointerOverlaps_dyn() ); }
		if (HX_FIELD_EQ(inName,"pointerFlxPoint") ) { return ::hx::Val( pointerFlxPoint_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"controllerPointer") ) { return ::hx::Val( controllerPointer ); }
		if (HX_FIELD_EQ(inName,"centerHexTypeLine") ) { return ::hx::Val( centerHexTypeLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeColorAlphabet") ) { return ::hx::Val( makeColorAlphabet_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWheelSelector") ) { return ::hx::Val( colorWheelSelector ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"hexTypeVisibleTimer") ) { return ::hx::Val( hexTypeVisibleTimer ); }
		if (HX_FIELD_EQ(inName,"_lastControllerMode") ) { return ::hx::Val( _lastControllerMode ); }
		if (HX_FIELD_EQ(inName,"changeSelectionMode") ) { return ::hx::Val( changeSelectionMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"changeSelectionNote") ) { return ::hx::Val( changeSelectionNote_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"colorGradientSelector") ) { return ::hx::Val( colorGradientSelector ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val NotesSubState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"modeBG") ) { modeBG=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tipTxt") ) { tipTxt=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onPixel") ) { onPixel=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"notesBG") ) { notesBG=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"myNotes") ) { myNotes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bigNote") ) { bigNote=inValue.Cast<  ::objects::Note >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"skinNote") ) { skinNote=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"dataArray") ) { dataArray=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetR") ) { alphabetR=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetG") ) { alphabetG=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetB") ) { alphabetB=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"modeNotes") ) { modeNotes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hexTypeNum") ) { hexTypeNum=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"copyButton") ) { copyButton=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorWheel") ) { colorWheel=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"hexTypeLine") ) { hexTypeLine=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pasteButton") ) { pasteButton=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetHex") ) { alphabetHex=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"onModeColumn") ) { onModeColumn=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorPalette") ) { colorPalette=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_storedColor") ) { _storedColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"changingNote") ) { changingNote=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingOnObj") ) { holdingOnObj=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"colorGradient") ) { colorGradient=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curSelectedMode") ) { curSelectedMode=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curSelectedNote") ) { curSelectedNote=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"allowedTypeKeys") ) { allowedTypeKeys=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"controllerPointer") ) { controllerPointer=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWheelSelector") ) { colorWheelSelector=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"hexTypeVisibleTimer") ) { hexTypeVisibleTimer=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_lastControllerMode") ) { _lastControllerMode=inValue.Cast< bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"colorGradientSelector") ) { colorGradientSelector=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void NotesSubState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("onModeColumn",98,64,71,e9));
	outFields->push(HX_("curSelectedMode",fe,04,4b,47));
	outFields->push(HX_("curSelectedNote",8d,49,f4,47));
	outFields->push(HX_("onPixel",e7,64,e1,58));
	outFields->push(HX_("dataArray",0f,ef,7e,6b));
	outFields->push(HX_("hexTypeLine",c9,ed,15,a7));
	outFields->push(HX_("hexTypeNum",11,5a,3d,ed));
	outFields->push(HX_("hexTypeVisibleTimer",c8,0c,57,76));
	outFields->push(HX_("copyButton",87,c7,a4,8f));
	outFields->push(HX_("pasteButton",a5,e9,40,61));
	outFields->push(HX_("colorGradient",73,02,02,2d));
	outFields->push(HX_("colorGradientSelector",b2,1c,65,2f));
	outFields->push(HX_("colorPalette",58,8b,ba,95));
	outFields->push(HX_("colorWheel",38,4c,26,ee));
	outFields->push(HX_("colorWheelSelector",77,33,40,df));
	outFields->push(HX_("alphabetR",3f,a0,34,f0));
	outFields->push(HX_("alphabetG",34,a0,34,f0));
	outFields->push(HX_("alphabetB",2f,a0,34,f0));
	outFields->push(HX_("alphabetHex",e8,2f,c5,de));
	outFields->push(HX_("modeBG",e8,eb,c6,c0));
	outFields->push(HX_("notesBG",46,68,6b,4d));
	outFields->push(HX_("controllerPointer",81,db,f4,1b));
	outFields->push(HX_("_lastControllerMode",34,63,09,11));
	outFields->push(HX_("tipTxt",d5,cf,c0,20));
	outFields->push(HX_("_storedColor",01,57,07,9c));
	outFields->push(HX_("changingNote",3f,d5,59,d6));
	outFields->push(HX_("holdingOnObj",15,34,32,64));
	outFields->push(HX_("allowedTypeKeys",16,fb,41,3c));
	outFields->push(HX_("skinNote",0f,dd,91,98));
	outFields->push(HX_("modeNotes",de,51,0f,71));
	outFields->push(HX_("myNotes",35,85,ca,48));
	outFields->push(HX_("bigNote",d2,5c,d9,68));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo NotesSubState_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,onModeColumn),HX_("onModeColumn",98,64,71,e9)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,curSelectedMode),HX_("curSelectedMode",fe,04,4b,47)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,curSelectedNote),HX_("curSelectedNote",8d,49,f4,47)},
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,onPixel),HX_("onPixel",e7,64,e1,58)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(NotesSubState_obj,dataArray),HX_("dataArray",0f,ef,7e,6b)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,hexTypeLine),HX_("hexTypeLine",c9,ed,15,a7)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,hexTypeNum),HX_("hexTypeNum",11,5a,3d,ed)},
	{::hx::fsFloat,(int)offsetof(NotesSubState_obj,hexTypeVisibleTimer),HX_("hexTypeVisibleTimer",c8,0c,57,76)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,copyButton),HX_("copyButton",87,c7,a4,8f)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,pasteButton),HX_("pasteButton",a5,e9,40,61)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorGradient),HX_("colorGradient",73,02,02,2d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorGradientSelector),HX_("colorGradientSelector",b2,1c,65,2f)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorPalette),HX_("colorPalette",58,8b,ba,95)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorWheel),HX_("colorWheel",38,4c,26,ee)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorWheelSelector),HX_("colorWheelSelector",77,33,40,df)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetR),HX_("alphabetR",3f,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetG),HX_("alphabetG",34,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetB),HX_("alphabetB",2f,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetHex),HX_("alphabetHex",e8,2f,c5,de)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,modeBG),HX_("modeBG",e8,eb,c6,c0)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,notesBG),HX_("notesBG",46,68,6b,4d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,controllerPointer),HX_("controllerPointer",81,db,f4,1b)},
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,_lastControllerMode),HX_("_lastControllerMode",34,63,09,11)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(NotesSubState_obj,tipTxt),HX_("tipTxt",d5,cf,c0,20)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,_storedColor),HX_("_storedColor",01,57,07,9c)},
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,changingNote),HX_("changingNote",3f,d5,59,d6)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,holdingOnObj),HX_("holdingOnObj",15,34,32,64)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(NotesSubState_obj,allowedTypeKeys),HX_("allowedTypeKeys",16,fb,41,3c)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,skinNote),HX_("skinNote",0f,dd,91,98)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(NotesSubState_obj,modeNotes),HX_("modeNotes",de,51,0f,71)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(NotesSubState_obj,myNotes),HX_("myNotes",35,85,ca,48)},
	{::hx::fsObject /*  ::objects::Note */ ,(int)offsetof(NotesSubState_obj,bigNote),HX_("bigNote",d2,5c,d9,68)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *NotesSubState_obj_sStaticStorageInfo = 0;
#endif

static ::String NotesSubState_obj_sMemberFields[] = {
	HX_("onModeColumn",98,64,71,e9),
	HX_("curSelectedMode",fe,04,4b,47),
	HX_("curSelectedNote",8d,49,f4,47),
	HX_("onPixel",e7,64,e1,58),
	HX_("dataArray",0f,ef,7e,6b),
	HX_("hexTypeLine",c9,ed,15,a7),
	HX_("hexTypeNum",11,5a,3d,ed),
	HX_("hexTypeVisibleTimer",c8,0c,57,76),
	HX_("copyButton",87,c7,a4,8f),
	HX_("pasteButton",a5,e9,40,61),
	HX_("colorGradient",73,02,02,2d),
	HX_("colorGradientSelector",b2,1c,65,2f),
	HX_("colorPalette",58,8b,ba,95),
	HX_("colorWheel",38,4c,26,ee),
	HX_("colorWheelSelector",77,33,40,df),
	HX_("alphabetR",3f,a0,34,f0),
	HX_("alphabetG",34,a0,34,f0),
	HX_("alphabetB",2f,a0,34,f0),
	HX_("alphabetHex",e8,2f,c5,de),
	HX_("modeBG",e8,eb,c6,c0),
	HX_("notesBG",46,68,6b,4d),
	HX_("controllerPointer",81,db,f4,1b),
	HX_("_lastControllerMode",34,63,09,11),
	HX_("tipTxt",d5,cf,c0,20),
	HX_("updateTip",d2,3e,e5,82),
	HX_("_storedColor",01,57,07,9c),
	HX_("changingNote",3f,d5,59,d6),
	HX_("holdingOnObj",15,34,32,64),
	HX_("allowedTypeKeys",16,fb,41,3c),
	HX_("update",09,86,05,87),
	HX_("pointerOverlaps",e9,d4,f8,c3),
	HX_("pointerX",fb,e4,66,ac),
	HX_("pointerY",fc,e4,66,ac),
	HX_("pointerFlxPoint",5b,04,86,28),
	HX_("centerHexTypeLine",f4,b5,6b,cc),
	HX_("changeSelectionMode",3f,a6,f0,a1),
	HX_("changeSelectionNote",ce,ea,99,a2),
	HX_("makeColorAlphabet",68,3e,89,ba),
	HX_("skinNote",0f,dd,91,98),
	HX_("modeNotes",de,51,0f,71),
	HX_("myNotes",35,85,ca,48),
	HX_("bigNote",d2,5c,d9,68),
	HX_("spawnNotes",06,38,e3,d9),
	HX_("updateNotes",78,45,63,85),
	HX_("updateColors",99,6c,4a,c6),
	HX_("setShaderColor",7c,57,47,c9),
	HX_("getShaderColor",08,6f,27,a9),
	HX_("getShader",5b,48,77,99),
	::String(null()) };

::hx::Class NotesSubState_obj::__mClass;

void NotesSubState_obj::__register()
{
	NotesSubState_obj _hx_dummy;
	NotesSubState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("options.NotesSubState",a2,74,fa,0a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(NotesSubState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< NotesSubState_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NotesSubState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NotesSubState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace options
