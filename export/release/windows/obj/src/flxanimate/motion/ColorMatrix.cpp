// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flxanimate_motion_ColorMatrix
#include <flxanimate/motion/ColorMatrix.h>
#endif
#ifndef INCLUDED_flxanimate_motion_DynamicMatrix
#include <flxanimate/motion/DynamicMatrix.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_ObjectVector
#include <openfl/_Vector/ObjectVector.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_21_new,"flxanimate.motion.ColorMatrix","new",0xba11d0bd,"flxanimate.motion.ColorMatrix.new","flxanimate/motion/ColorMatrix.hx",21,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_30_setBrightnessMatrix,"flxanimate.motion.ColorMatrix","setBrightnessMatrix",0xe5109111,"flxanimate.motion.ColorMatrix.setBrightnessMatrix","flxanimate/motion/ColorMatrix.hx",30,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_42_setContrastMatrix,"flxanimate.motion.ColorMatrix","setContrastMatrix",0xf471d542,"flxanimate.motion.ColorMatrix.setContrastMatrix","flxanimate/motion/ColorMatrix.hx",42,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_59_setSaturationMatrix,"flxanimate.motion.ColorMatrix","setSaturationMatrix",0x824ecdd2,"flxanimate.motion.ColorMatrix.setSaturationMatrix","flxanimate/motion/ColorMatrix.hx",59,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_108_setHueMatrix,"flxanimate.motion.ColorMatrix","setHueMatrix",0x4c54a11a,"flxanimate.motion.ColorMatrix.setHueMatrix","flxanimate/motion/ColorMatrix.hx",108,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_181_getFlatArray,"flxanimate.motion.ColorMatrix","getFlatArray",0x1222dbad,"flxanimate.motion.ColorMatrix.getFlatArray","flxanimate/motion/ColorMatrix.hx",181,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_13_boot,"flxanimate.motion.ColorMatrix","boot",0x0d9dd535,"flxanimate.motion.ColorMatrix.boot","flxanimate/motion/ColorMatrix.hx",13,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_14_boot,"flxanimate.motion.ColorMatrix","boot",0x0d9dd535,"flxanimate.motion.ColorMatrix.boot","flxanimate/motion/ColorMatrix.hx",14,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_15_boot,"flxanimate.motion.ColorMatrix","boot",0x0d9dd535,"flxanimate.motion.ColorMatrix.boot","flxanimate/motion/ColorMatrix.hx",15,0xc8e73f73)
namespace flxanimate{
namespace motion{

void ColorMatrix_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_21_new)
HXLINE(  22)		super::__construct(5,5);
HXLINE(  23)		this->loadIdentity();
            	}

Dynamic ColorMatrix_obj::__CreateEmpty() { return new ColorMatrix_obj; }

void *ColorMatrix_obj::_hx_vtable = 0;

Dynamic ColorMatrix_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ColorMatrix_obj > _hx_result = new ColorMatrix_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ColorMatrix_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x685fb6df) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x685fb6df;
	} else {
		return inClassId==(int)0x79460ebb;
	}
}

void ColorMatrix_obj::setBrightnessMatrix(Float value){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_30_setBrightnessMatrix)
HXLINE(  31)		if (::hx::IsNull( this->m_matrix )) {
HXLINE(  31)			return;
            		}
HXLINE(  33)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(4,value);
HXLINE(  34)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(4,value);
HXLINE(  35)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(4,value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setBrightnessMatrix,(void))

void ColorMatrix_obj::setContrastMatrix(Float value){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_42_setContrastMatrix)
HXLINE(  43)		if (::hx::IsNull( this->m_matrix )) {
HXLINE(  43)			return;
            		}
HXLINE(  45)		Float brightness = (((Float)0.5) * (((Float)127.0) - value));
HXLINE(  46)		value = (value / ( (Float)(127) ));
HXLINE(  48)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,value);
HXLINE(  49)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,value);
HXLINE(  50)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,value);
HXLINE(  52)		this->setBrightnessMatrix(brightness);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setContrastMatrix,(void))

void ColorMatrix_obj::setSaturationMatrix(Float value){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_59_setSaturationMatrix)
HXLINE(  60)		if (::hx::IsNull( this->m_matrix )) {
HXLINE(  60)			return;
            		}
HXLINE(  62)		Float subVal = (((Float)1.0) - value);
HXLINE(  64)		Float mulVal = (subVal * ::flxanimate::motion::ColorMatrix_obj::lumR);
HXLINE(  65)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,(mulVal + value));
HXLINE(  66)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,mulVal);
HXLINE(  67)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,mulVal);
HXLINE(  69)		mulVal = (subVal * ::flxanimate::motion::ColorMatrix_obj::lumG);
HXLINE(  70)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,mulVal);
HXLINE(  71)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,(mulVal + value));
HXLINE(  72)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,mulVal);
HXLINE(  74)		mulVal = (subVal * ::flxanimate::motion::ColorMatrix_obj::lumB);
HXLINE(  75)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,mulVal);
HXLINE(  76)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,mulVal);
HXLINE(  77)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,(mulVal + value));
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setSaturationMatrix,(void))

void ColorMatrix_obj::setHueMatrix(Float angle){
            	HX_GC_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_108_setHueMatrix)
HXLINE( 109)		if (::hx::IsNull( this->m_matrix )) {
HXLINE( 109)			return;
            		}
HXLINE( 111)		this->loadIdentity();
HXLINE( 113)		 ::flxanimate::motion::DynamicMatrix baseMat =  ::flxanimate::motion::DynamicMatrix_obj::__alloc( HX_CTX ,3,3);
HXLINE( 114)		 ::flxanimate::motion::DynamicMatrix cosBaseMat =  ::flxanimate::motion::DynamicMatrix_obj::__alloc( HX_CTX ,3,3);
HXLINE( 115)		 ::flxanimate::motion::DynamicMatrix sinBaseMat =  ::flxanimate::motion::DynamicMatrix_obj::__alloc( HX_CTX ,3,3);
HXLINE( 117)		Float cosValue = ::Math_obj::cos(angle);
HXLINE( 118)		Float sinValue = ::Math_obj::sin(angle);
HXLINE( 120)		Float lumR = ((Float)0.213);
HXLINE( 121)		Float lumG = ((Float)0.715);
HXLINE( 122)		Float lumB = ((Float)0.072);
HXLINE( 124)		baseMat->setValue(0,0,lumR);
HXLINE( 125)		baseMat->setValue(1,0,lumR);
HXLINE( 126)		baseMat->setValue(2,0,lumR);
HXLINE( 128)		baseMat->setValue(0,1,lumG);
HXLINE( 129)		baseMat->setValue(1,1,lumG);
HXLINE( 130)		baseMat->setValue(2,1,lumG);
HXLINE( 132)		baseMat->setValue(0,2,lumB);
HXLINE( 133)		baseMat->setValue(1,2,lumB);
HXLINE( 134)		baseMat->setValue(2,2,lumB);
HXLINE( 136)		cosBaseMat->setValue(0,0,(( (Float)(1) ) - lumR));
HXLINE( 137)		cosBaseMat->setValue(1,0,-(lumR));
HXLINE( 138)		cosBaseMat->setValue(2,0,-(lumR));
HXLINE( 140)		cosBaseMat->setValue(0,1,-(lumG));
HXLINE( 141)		cosBaseMat->setValue(1,1,(( (Float)(1) ) - lumG));
HXLINE( 142)		cosBaseMat->setValue(2,1,-(lumG));
HXLINE( 144)		cosBaseMat->setValue(0,2,-(lumB));
HXLINE( 145)		cosBaseMat->setValue(1,2,-(lumB));
HXLINE( 146)		cosBaseMat->setValue(2,2,(( (Float)(1) ) - lumB));
HXLINE( 148)		cosBaseMat->multiplyNumber(cosValue);
HXLINE( 150)		sinBaseMat->setValue(0,0,-(lumR));
HXLINE( 151)		sinBaseMat->setValue(1,0,((lumR - lumB) + ((Float)0.002)));
HXLINE( 152)		sinBaseMat->setValue(2,0,-((( (Float)(1) ) - lumR)));
HXLINE( 154)		sinBaseMat->setValue(0,1,-(lumG));
HXLINE( 155)		sinBaseMat->setValue(1,1,((lumR - lumB) - ((Float)0.001)));
HXLINE( 156)		sinBaseMat->setValue(2,1,lumG);
HXLINE( 158)		sinBaseMat->setValue(0,2,(( (Float)(1) ) - lumB));
HXLINE( 159)		sinBaseMat->setValue(1,2,(-((lumR + lumB)) + ((Float)0.002)));
HXLINE( 160)		sinBaseMat->setValue(2,2,lumB);
HXLINE( 162)		sinBaseMat->multiplyNumber(sinValue);
HXLINE( 164)		baseMat->add(cosBaseMat);
HXLINE( 165)		baseMat->add(sinBaseMat);
HXLINE( 167)		{
HXLINE( 167)			int _g = 0;
HXDLIN( 167)			while((_g < 3)){
HXLINE( 167)				_g = (_g + 1);
HXDLIN( 167)				int i = (_g - 1);
HXLINE( 169)				{
HXLINE( 169)					int _g1 = 0;
HXDLIN( 169)					while((_g1 < 3)){
HXLINE( 169)						_g1 = (_g1 + 1);
HXDLIN( 169)						int j = (_g1 - 1);
HXLINE( 171)						{
HXLINE( 171)							::Dynamic this1 = this->m_matrix->get(i).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 171)							( ( ::openfl::_Vector::FloatVector)(this1) )->set(j,baseMat->getValue(i,j));
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setHueMatrix,(void))

::Array< Float > ColorMatrix_obj::getFlatArray(){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_181_getFlatArray)
HXLINE( 182)		if (::hx::IsNull( this->m_matrix )) {
HXLINE( 182)			return null();
            		}
HXLINE( 184)		int index = 0;
HXLINE( 185)		::Array< Float > ptr = ::Array_obj< Float >::__new(0);
HXLINE( 186)		{
HXLINE( 186)			int _g = 0;
HXDLIN( 186)			while((_g < 4)){
HXLINE( 186)				_g = (_g + 1);
HXDLIN( 186)				int i = (_g - 1);
HXLINE( 188)				{
HXLINE( 188)					int _g1 = 0;
HXDLIN( 188)					while((_g1 < 5)){
HXLINE( 188)						_g1 = (_g1 + 1);
HXDLIN( 188)						int j = (_g1 - 1);
HXLINE( 190)						ptr[index] = this->m_matrix->get(i).StaticCast<  ::openfl::_Vector::FloatVector >()->get(j);
HXLINE( 192)						index = (index + 1);
            					}
            				}
            			}
            		}
HXLINE( 196)		return ptr;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ColorMatrix_obj,getFlatArray,return )

Float ColorMatrix_obj::lumR;

Float ColorMatrix_obj::lumG;

Float ColorMatrix_obj::lumB;


::hx::ObjectPtr< ColorMatrix_obj > ColorMatrix_obj::__new() {
	::hx::ObjectPtr< ColorMatrix_obj > __this = new ColorMatrix_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< ColorMatrix_obj > ColorMatrix_obj::__alloc(::hx::Ctx *_hx_ctx) {
	ColorMatrix_obj *__this = (ColorMatrix_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ColorMatrix_obj), true, "flxanimate.motion.ColorMatrix"));
	*(void **)__this = ColorMatrix_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ColorMatrix_obj::ColorMatrix_obj()
{
}

::hx::Val ColorMatrix_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"setHueMatrix") ) { return ::hx::Val( setHueMatrix_dyn() ); }
		if (HX_FIELD_EQ(inName,"getFlatArray") ) { return ::hx::Val( getFlatArray_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"setContrastMatrix") ) { return ::hx::Val( setContrastMatrix_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"setBrightnessMatrix") ) { return ::hx::Val( setBrightnessMatrix_dyn() ); }
		if (HX_FIELD_EQ(inName,"setSaturationMatrix") ) { return ::hx::Val( setSaturationMatrix_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ColorMatrix_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lumR") ) { outValue = ( lumR ); return true; }
		if (HX_FIELD_EQ(inName,"lumG") ) { outValue = ( lumG ); return true; }
		if (HX_FIELD_EQ(inName,"lumB") ) { outValue = ( lumB ); return true; }
	}
	return false;
}

bool ColorMatrix_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lumR") ) { lumR=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"lumG") ) { lumG=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"lumB") ) { lumB=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ColorMatrix_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo ColorMatrix_obj_sStaticStorageInfo[] = {
	{::hx::fsFloat,(void *) &ColorMatrix_obj::lumR,HX_("lumR",0e,32,bc,47)},
	{::hx::fsFloat,(void *) &ColorMatrix_obj::lumG,HX_("lumG",03,32,bc,47)},
	{::hx::fsFloat,(void *) &ColorMatrix_obj::lumB,HX_("lumB",fe,31,bc,47)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String ColorMatrix_obj_sMemberFields[] = {
	HX_("setBrightnessMatrix",b4,46,bf,bc),
	HX_("setContrastMatrix",25,cc,ca,ca),
	HX_("setSaturationMatrix",75,83,fd,59),
	HX_("setHueMatrix",17,15,c5,52),
	HX_("getFlatArray",aa,4f,93,18),
	::String(null()) };

static void ColorMatrix_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ColorMatrix_obj::lumR,"lumR");
	HX_MARK_MEMBER_NAME(ColorMatrix_obj::lumG,"lumG");
	HX_MARK_MEMBER_NAME(ColorMatrix_obj::lumB,"lumB");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ColorMatrix_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ColorMatrix_obj::lumR,"lumR");
	HX_VISIT_MEMBER_NAME(ColorMatrix_obj::lumG,"lumG");
	HX_VISIT_MEMBER_NAME(ColorMatrix_obj::lumB,"lumB");
};

#endif

::hx::Class ColorMatrix_obj::__mClass;

static ::String ColorMatrix_obj_sStaticFields[] = {
	HX_("lumR",0e,32,bc,47),
	HX_("lumG",03,32,bc,47),
	HX_("lumB",fe,31,bc,47),
	::String(null())
};

void ColorMatrix_obj::__register()
{
	ColorMatrix_obj _hx_dummy;
	ColorMatrix_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flxanimate.motion.ColorMatrix",4b,ae,d9,d2);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ColorMatrix_obj::__GetStatic;
	__mClass->mSetStaticField = &ColorMatrix_obj::__SetStatic;
	__mClass->mMarkFunc = ColorMatrix_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ColorMatrix_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ColorMatrix_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ColorMatrix_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ColorMatrix_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ColorMatrix_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ColorMatrix_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ColorMatrix_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_13_boot)
HXDLIN(  13)		lumR = ((Float)0.3086);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_14_boot)
HXDLIN(  14)		lumG = ((Float)0.6094);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_15_boot)
HXDLIN(  15)		lumB = ((Float)0.0820);
            	}
}

} // end namespace flxanimate
} // end namespace motion
