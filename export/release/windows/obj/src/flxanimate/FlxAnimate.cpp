// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxImageFrame
#include <flixel/graphics/frames/FlxImageFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_path_FlxPath
#include <flixel/path/FlxPath.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flxanimate_FlxAnimate
#include <flxanimate/FlxAnimate.h>
#endif
#ifndef INCLUDED_flxanimate_animate_ButtonEvent
#include <flxanimate/animate/ButtonEvent.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxAnim
#include <flxanimate/animate/FlxAnim.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxElement
#include <flxanimate/animate/FlxElement.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxKeyFrame
#include <flxanimate/animate/FlxKeyFrame.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxLayer
#include <flxanimate/animate/FlxLayer.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxMetaData
#include <flxanimate/animate/FlxMetaData.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxSymbol
#include <flxanimate/animate/FlxSymbol.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxTimeline
#include <flxanimate/animate/FlxTimeline.h>
#endif
#ifndef INCLUDED_flxanimate_animate_SymbolParameters
#include <flxanimate/animate/SymbolParameters.h>
#endif
#ifndef INCLUDED_flxanimate_data_Loop
#include <flxanimate/data/Loop.h>
#endif
#ifndef INCLUDED_flxanimate_data_SymbolT
#include <flxanimate/data/SymbolT.h>
#endif
#ifndef INCLUDED_flxanimate_display_FlxAnimateFilterRenderer
#include <flxanimate/display/FlxAnimateFilterRenderer.h>
#endif
#ifndef INCLUDED_flxanimate_effects_FlxColorEffect
#include <flxanimate/effects/FlxColorEffect.h>
#endif
#ifndef INCLUDED_flxanimate_frames_FlxAnimateFrames
#include <flxanimate/frames/FlxAnimateFrames.h>
#endif
#ifndef INCLUDED_flxanimate_zip_Zip
#include <flxanimate/zip/Zip.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_List
#include <haxe/ds/List.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_ds__List_ListNode
#include <haxe/ds/_List/ListNode.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool
#include <lime/utils/ObjectPool.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_utils_Assets
#include <openfl/utils/Assets.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5067d88e43c2dc01_48_new,"flxanimate.FlxAnimate","new",0x7e9fba00,"flxanimate.FlxAnimate.new","flxanimate/FlxAnimate.hx",48,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_100_loadAtlas,"flxanimate.FlxAnimate","loadAtlas",0x111f7ae5,"flxanimate.FlxAnimate.loadAtlas","flxanimate/FlxAnimate.hx",100,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_115_draw,"flxanimate.FlxAnimate","draw",0x4690ae64,"flxanimate.FlxAnimate.draw","flxanimate/FlxAnimate.hx",115,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_148_parseElement,"flxanimate.FlxAnimate","parseElement",0x3628e529,"flxanimate.FlxAnimate.parseElement","flxanimate/FlxAnimate.hx",148,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_291_renderFilter,"flxanimate.FlxAnimate","renderFilter",0xca85060e,"flxanimate.FlxAnimate.renderFilter","flxanimate/FlxAnimate.hx",291,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_325_applyFilter,"flxanimate.FlxAnimate","applyFilter",0x91ee6966,"flxanimate.FlxAnimate.applyFilter","flxanimate/FlxAnimate.hx",325,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_353_setButtonFrames,"flxanimate.FlxAnimate","setButtonFrames",0x804d339a,"flxanimate.FlxAnimate.setButtonFrames","flxanimate/FlxAnimate.hx",353,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_398_drawLimb,"flxanimate.FlxAnimate","drawLimb",0x4e1df396,"flxanimate.FlxAnimate.drawLimb","flxanimate/FlxAnimate.hx",398,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_465_limbOnScreen,"flxanimate.FlxAnimate","limbOnScreen",0x0ed1497d,"flxanimate.FlxAnimate.limbOnScreen","flxanimate/FlxAnimate.hx",465,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_485_destroy,"flxanimate.FlxAnimate","destroy",0xa197669a,"flxanimate.FlxAnimate.destroy","flxanimate/FlxAnimate.hx",485,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_499_updateAnimation,"flxanimate.FlxAnimate","updateAnimation",0xa813995b,"flxanimate.FlxAnimate.updateAnimation","flxanimate/FlxAnimate.hx",499,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_505_setButtonPack,"flxanimate.FlxAnimate","setButtonPack",0xba6cb5cd,"flxanimate.FlxAnimate.setButtonPack","flxanimate/FlxAnimate.hx",505,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_512_setTheSettings,"flxanimate.FlxAnimate","setTheSettings",0x7af46852,"flxanimate.FlxAnimate.setTheSettings","flxanimate/FlxAnimate.hx",512,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_538_atlasSetting,"flxanimate.FlxAnimate","atlasSetting",0xd7d0ade5,"flxanimate.FlxAnimate.atlasSetting","flxanimate/FlxAnimate.hx",538,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_573_loadAtlasEx,"flxanimate.FlxAnimate","loadAtlasEx",0x341ffab8,"flxanimate.FlxAnimate.loadAtlasEx","flxanimate/FlxAnimate.hx",573,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_632__removeBOM,"flxanimate.FlxAnimate","_removeBOM",0x8102c63d,"flxanimate.FlxAnimate._removeBOM","flxanimate/FlxAnimate.hx",632,0x8666d8cf)
namespace flxanimate{

void FlxAnimate_obj::__construct(::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y,::String Path, ::Dynamic Settings){
            		Float X = __o_X.Default(0);
            		Float Y = __o_Y.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_48_new)
HXLINE( 396)		this->_mat =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 351)		this->pressed = false;
HXLINE(  65)		this->renderer =  ::flxanimate::display::FlxAnimateFilterRenderer_obj::__alloc( HX_CTX );
HXLINE(  60)		this->showPivot = false;
HXLINE(  86)		super::__construct(X,Y,null());
HXLINE(  87)		this->_sprite =  ::openfl::display::Sprite_obj::__alloc( HX_CTX );
HXLINE(  88)		this->anim =  ::flxanimate::animate::FlxAnim_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this),null());
HXLINE(  89)		if (::hx::IsNotNull( Path )) {
HXLINE(  90)			this->loadAtlas(Path);
            		}
HXLINE(  91)		if (::hx::IsNotNull( Settings )) {
HXLINE(  92)			this->setTheSettings(Settings);
            		}
HXLINE(  93)		this->_pivot = ::flixel::graphics::FlxGraphic_obj::fromBitmapData(::openfl::utils::Assets_obj::getBitmapData(HX_("flxanimate/images/pivot.png",86,22,15,80),null()),null(),HX_("__pivot",a2,a3,00,2d),null())->get_imageFrame()->get_frame();
HXLINE(  94)		this->_indicator = ::flixel::graphics::FlxGraphic_obj::fromBitmapData(::openfl::utils::Assets_obj::getBitmapData(HX_("flxanimate/images/indicator.png",93,c2,f2,28),null()),null(),HX_("__indicator",af,30,da,c1),null())->get_imageFrame()->get_frame();
HXLINE(  95)		this->get_camera()->canvas->addChild(this->_sprite);
HXLINE(  96)		this->rect = ::openfl::geom::Rectangle_obj::_hx___pool->get().StaticCast<  ::openfl::geom::Rectangle >();
            	}

Dynamic FlxAnimate_obj::__CreateEmpty() { return new FlxAnimate_obj; }

void *FlxAnimate_obj::_hx_vtable = 0;

Dynamic FlxAnimate_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxAnimate_obj > _hx_result = new FlxAnimate_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool FlxAnimate_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2c01639b) {
		if (inClassId<=(int)0x0943d942) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0943d942;
		} else {
			return inClassId==(int)0x2c01639b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void FlxAnimate_obj::loadAtlas(::String Path){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_100_loadAtlas)
HXLINE( 101)		bool _hx_tmp;
HXDLIN( 101)		if ((::haxe::io::Path_obj::extension(Path) != HX_("zip",e1,ee,5c,00))) {
HXLINE( 101)			_hx_tmp = !(::sys::FileSystem_obj::exists(((HX_("",00,00,00,00) + Path) + HX_("/Animation.json",61,fc,54,44))));
            		}
            		else {
HXLINE( 101)			_hx_tmp = false;
            		}
HXDLIN( 101)		if (_hx_tmp) {
HXLINE( 103)			{
HXLINE( 103)				 ::flixel::_hx_system::frontEnds::LogFrontEnd _this = ::flixel::FlxG_obj::log;
HXDLIN( 103)				 ::Dynamic data = ((HX_("Animation file not found in specified path: \"",bf,3c,8d,58) + ::Std_obj::string(this->path)) + HX_("\", have you written the correct path?",a9,4e,46,6b));
HXDLIN( 103)				_this->advanced(data,::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true);
            			}
HXLINE( 104)			return;
            		}
HXLINE( 106)		 ::flxanimate::animate::FlxAnim _hx_tmp1 = this->anim;
HXDLIN( 106)		_hx_tmp1->_loadAtlas(this->atlasSetting(Path));
HXLINE( 107)		this->set_frames(::flxanimate::frames::FlxAnimateFrames_obj::fromTextureAtlas(Path));
HXLINE( 108)		this->origin = this->anim->curInstance->symbol->transformationPoint;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,loadAtlas,(void))

void FlxAnimate_obj::draw(){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_115_draw)
HXLINE( 116)		this->_matrix->identity();
HXLINE( 117)		if (this->flipX) {
HXLINE( 119)			 ::flixel::math::FlxMatrix fh = this->_matrix;
HXDLIN( 119)			fh->a = (fh->a * ( (Float)(-1) ));
HXLINE( 120)			 ::flixel::math::FlxMatrix fh1 = this->_matrix;
HXDLIN( 120)			Float fh2 = fh1->tx;
HXDLIN( 120)			fh1->tx = (fh2 + this->get_width());
            		}
HXLINE( 122)		if (this->flipY) {
HXLINE( 124)			 ::flixel::math::FlxMatrix fh3 = this->_matrix;
HXDLIN( 124)			fh3->d = (fh3->d * ( (Float)(-1) ));
HXLINE( 125)			 ::flixel::math::FlxMatrix fh4 = this->_matrix;
HXDLIN( 125)			Float fh5 = fh4->ty;
HXDLIN( 125)			fh4->ty = (fh5 + this->get_height());
            		}
HXLINE( 127)		this->frameWidth = 0;
HXLINE( 128)		this->frameHeight = 0;
HXLINE( 129)		this->set_width(( (Float)(0) ));
HXLINE( 130)		this->set_height(( (Float)(0) ));
HXLINE( 131)		this->_flashRect->setEmpty();
HXLINE( 133)		 ::flxanimate::animate::FlxElement _hx_tmp = this->anim->curInstance;
HXDLIN( 133)		int _hx_tmp1 = this->anim->get_curFrame();
HXDLIN( 133)		 ::flixel::math::FlxMatrix _hx_tmp2 = this->_matrix;
HXDLIN( 133)		 ::openfl::geom::ColorTransform _hx_tmp3 = this->colorTransform;
HXDLIN( 133)		this->parseElement(_hx_tmp,_hx_tmp1,_hx_tmp2,_hx_tmp3,true,null(),this->get_cameras());
HXLINE( 135)		this->set_width(this->_flashRect->width);
HXLINE( 136)		this->set_height(this->_flashRect->height);
HXLINE( 137)		this->frameWidth = ::Std_obj::_hx_int(this->get_width());
HXLINE( 138)		this->frameHeight = ::Std_obj::_hx_int(this->get_height());
HXLINE( 140)		if (this->showPivot) {
HXLINE( 142)			 ::flixel::graphics::frames::FlxFrame _hx_tmp4 = this->_pivot;
HXDLIN( 142)			 ::flixel::math::FlxMatrix _hx_tmp5 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,1,0,0,1,(this->origin->x - (this->_pivot->frame->width * ((Float)0.5))),(this->origin->y - (this->_pivot->frame->height * ((Float)0.5))));
HXDLIN( 142)			this->drawLimb(_hx_tmp4,_hx_tmp5,null(),null(),this->get_cameras());
HXLINE( 143)			 ::flixel::graphics::frames::FlxFrame _hx_tmp6 = this->_indicator;
HXDLIN( 143)			 ::flixel::math::FlxMatrix _hx_tmp7 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,1,0,0,1,(-(this->_indicator->frame->width) * ((Float)0.5)),(-(this->_indicator->frame->height) * ((Float)0.5)));
HXDLIN( 143)			this->drawLimb(_hx_tmp6,_hx_tmp7,null(),null(),this->get_cameras());
            		}
            	}


void FlxAnimate_obj::parseElement( ::flxanimate::animate::FlxElement instance,int curFrame, ::flixel::math::FlxMatrix m, ::openfl::geom::ColorTransform colorFilter,::hx::Null< bool >  __o_mainSymbol, ::Dynamic filterInstance,::Array< ::Dynamic> cameras){
            		bool mainSymbol = __o_mainSymbol.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_148_parseElement)
HXLINE( 149)		bool filterin = ::hx::IsNotNull( filterInstance );
HXLINE( 150)		if (::hx::IsNull( cameras )) {
HXLINE( 151)			cameras = this->get_cameras();
            		}
HXLINE( 153)		 ::flixel::math::FlxMatrix matrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 155)		matrix->concat(instance->matrix);
HXLINE( 156)		matrix->concat(m);
HXLINE( 159)		 ::openfl::geom::ColorTransform colorEffect =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXLINE( 160)		colorEffect->_hx___copyFrom(colorFilter);
HXLINE( 162)		 ::flxanimate::animate::FlxSymbol symbol;
HXDLIN( 162)		if (::hx::IsNotNull( instance->symbol )) {
HXLINE( 162)			symbol = ( ( ::flxanimate::animate::FlxSymbol)(this->anim->symbolDictionary->get(instance->symbol->name)) );
            		}
            		else {
HXLINE( 162)			symbol = null();
            		}
HXLINE( 164)		if (::hx::IsNotNull( instance->symbol )) {
HXLINE( 166)			if (::hx::IsNotNull( instance->symbol->colorEffect )) {
HXLINE( 167)				colorEffect->concat(instance->symbol->colorEffect->_hx___create());
            			}
HXLINE( 169)			if (instance->symbol->get_cacheAsBitmap()) {
HXLINE( 171)				if (instance->symbol->_renderDirty) {
HXLINE( 173)					instance->symbol->_renderDirty = false;
HXLINE( 174)					if (::hx::IsNull( this->filterCamera )) {
HXLINE( 175)						this->filterCamera =  ::flixel::FlxCamera_obj::__alloc( HX_CTX ,0,0,0,0,1);
            					}
HXLINE( 178)					instance->symbol->_cacheBitmapMatrix->copyFrom(instance->symbol->cacheAsBitmapMatrix);
HXLINE( 180)					 ::flixel::math::FlxMatrix instance1 = instance->symbol->_cacheBitmapMatrix;
HXDLIN( 180)					this->parseElement(instance,curFrame,instance1, ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null()),mainSymbol, ::Dynamic(::hx::Anon_obj::Create(1)
            						->setFixed(0,HX_("instance",95,1f,e1,59),instance)),::Array_obj< ::Dynamic>::__new(1)->init(0,this->filterCamera));
HXLINE( 183)					if (::hx::IsNull( instance->symbol->_filterBitmap )) {
HXLINE( 184)						instance->symbol->_filterBitmap = ::flixel::graphics::FlxGraphic_obj::fromRectangle(1,1,0,true,null())->get_imageFrame()->get_frame();
            					}
HXLINE( 187)					this->renderFilter(this->filterCamera,instance->symbol->filters,instance->symbol->_filterBitmap,instance->symbol->_cacheBitmapMatrix,this->renderer);
HXLINE( 188)					instance->symbol->_renderDirty = false;
            				}
HXLINE( 191)				bool _hx_tmp;
HXDLIN( 191)				bool _hx_tmp1;
HXDLIN( 191)				if (filterin) {
HXLINE( 191)					if (filterin) {
HXLINE( 191)						_hx_tmp1 = ::hx::IsInstanceNotEq( filterInstance->__Field(HX_("instance",95,1f,e1,59),::hx::paccDynamic),instance );
            					}
            					else {
HXLINE( 191)						_hx_tmp1 = false;
            					}
            				}
            				else {
HXLINE( 191)					_hx_tmp1 = true;
            				}
HXDLIN( 191)				if (_hx_tmp1) {
HXLINE( 191)					_hx_tmp = ::hx::IsNotNull( instance->symbol->_filterBitmap );
            				}
            				else {
HXLINE( 191)					_hx_tmp = false;
            				}
HXDLIN( 191)				if (_hx_tmp) {
HXLINE( 193)					matrix->identity();
HXLINE( 194)					matrix->concat(instance->symbol->_cacheBitmapMatrix);
HXLINE( 195)					matrix->concat(m);
HXLINE( 196)					this->drawLimb(instance->symbol->_filterBitmap,matrix,colorEffect,filterin,cameras);
HXLINE( 197)					return;
            				}
            			}
            		}
HXLINE( 202)		if (::hx::IsNotNull( instance->bitmap )) {
HXLINE( 204)			this->drawLimb(( ( ::flixel::graphics::frames::FlxFrame)(this->frames->framesByName->get(instance->bitmap)) ),matrix,colorEffect,filterin,cameras);
HXLINE( 205)			return;
            		}
HXLINE( 208)		int firstFrame = (instance->symbol->firstFrame + curFrame);
HXLINE( 209)		if ((instance->symbol->type->_hx_getIndex() == 2)) {
HXLINE( 211)			firstFrame = this->setButtonFrames(firstFrame);
            		}
HXLINE( 215)		switch((int)(instance->symbol->loop->_hx_getIndex())){
            			case (int)0: {
HXLINE( 217)				firstFrame = ::hx::Mod(firstFrame,symbol->get_length());
            			}
            			break;
            			case (int)1: {
HXLINE( 218)				 ::Dynamic Max = (symbol->get_length() - 1);
HXDLIN( 218)				Float lowerBound;
HXDLIN( 218)				if ((firstFrame < 0)) {
HXLINE( 218)					lowerBound = ( (Float)(0) );
            				}
            				else {
HXLINE( 218)					lowerBound = ( (Float)(firstFrame) );
            				}
HXDLIN( 218)				Float firstFrame1;
HXDLIN( 218)				bool firstFrame2;
HXDLIN( 218)				if (::hx::IsNotNull( Max )) {
HXLINE( 218)					firstFrame2 = ::hx::IsGreater( lowerBound,Max );
            				}
            				else {
HXLINE( 218)					firstFrame2 = false;
            				}
HXDLIN( 218)				if (firstFrame2) {
HXLINE( 218)					firstFrame1 = ( (Float)(Max) );
            				}
            				else {
HXLINE( 218)					firstFrame1 = lowerBound;
            				}
HXDLIN( 218)				firstFrame = ( (int)(firstFrame1) );
            			}
            			break;
            			default:{
            			}
            		}
HXLINE( 222)		::Array< ::Dynamic> layers = symbol->timeline->getList();
HXLINE( 223)		{
HXLINE( 223)			int _g = 0;
HXDLIN( 223)			int _g1 = layers->length;
HXDLIN( 223)			while((_g < _g1)){
HXLINE( 223)				_g = (_g + 1);
HXDLIN( 223)				int i = (_g - 1);
HXLINE( 225)				 ::flxanimate::animate::FlxLayer layer = layers->__get(((layers->length - 1) - i)).StaticCast<  ::flxanimate::animate::FlxLayer >();
HXLINE( 227)				bool _hx_tmp2;
HXDLIN( 227)				bool _hx_tmp3;
HXDLIN( 227)				if (!(layer->visible)) {
HXLINE( 227)					_hx_tmp3 = !(filterin);
            				}
            				else {
HXLINE( 227)					_hx_tmp3 = false;
            				}
HXDLIN( 227)				if (_hx_tmp3) {
HXLINE( 227)					_hx_tmp2 = mainSymbol;
            				}
            				else {
HXLINE( 227)					_hx_tmp2 = false;
            				}
HXDLIN( 227)				if (_hx_tmp2) {
HXLINE( 227)					continue;
            				}
HXLINE( 229)				layer->_setCurFrame(firstFrame);
HXLINE( 230)				 ::flxanimate::animate::FlxKeyFrame frame = layer->_currFrame;
HXLINE( 232)				if (::hx::IsNull( frame )) {
HXLINE( 232)					continue;
            				}
HXLINE( 234)				frame->update(firstFrame);
HXLINE( 236)				bool toBitmap = ::hx::IsNotNull( frame->filters );
HXLINE( 238)				if (toBitmap) {
HXLINE( 240)					bool _hx_tmp4;
HXDLIN( 240)					if (!(frame->_renderDirty)) {
HXLINE( 240)						_hx_tmp4 = ::hx::IsNotNull( frame->_filterFrame );
            					}
            					else {
HXLINE( 240)						_hx_tmp4 = false;
            					}
HXDLIN( 240)					if (_hx_tmp4) {
HXLINE( 242)						 ::flixel::math::FlxMatrix mat =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 243)						mat->concat(frame->_bitmapMatrix);
HXLINE( 244)						mat->concat(instance->matrix);
HXLINE( 245)						mat->concat(m);
HXLINE( 246)						this->drawLimb(frame->_filterFrame,mat,null(),filterin,cameras);
HXLINE( 247)						continue;
            					}
            					else {
HXLINE( 251)						frame->_filterFrame = ::flixel::graphics::FlxGraphic_obj::fromRectangle(1,1,0,true,null())->get_imageFrame()->get_frame();
HXLINE( 252)						if (::hx::IsNull( layer->_filterCamera )) {
HXLINE( 253)							layer->_filterCamera =  ::flixel::FlxCamera_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null());
            						}
            					}
            				}
HXLINE( 256)				{
HXLINE( 256)					int _g2 = 0;
HXDLIN( 256)					::Array< ::Dynamic> _g3 = frame->getList();
HXDLIN( 256)					while((_g2 < _g3->length)){
HXLINE( 256)						 ::flxanimate::animate::FlxElement element = _g3->__get(_g2).StaticCast<  ::flxanimate::animate::FlxElement >();
HXDLIN( 256)						_g2 = (_g2 + 1);
HXLINE( 258)						int firstframe = 0;
HXLINE( 259)						bool _hx_tmp5;
HXDLIN( 259)						bool _hx_tmp6;
HXDLIN( 259)						if (::hx::IsNotNull( element->symbol )) {
HXLINE( 259)							_hx_tmp6 = ::hx::IsPointerEq( element->symbol->type,::flxanimate::data::SymbolT_obj::Graphic_dyn() );
            						}
            						else {
HXLINE( 259)							_hx_tmp6 = false;
            						}
HXDLIN( 259)						if (_hx_tmp6) {
HXLINE( 259)							_hx_tmp5 = ::hx::IsPointerNotEq( element->symbol->loop,::flxanimate::data::Loop_obj::SingleFrame_dyn() );
            						}
            						else {
HXLINE( 259)							_hx_tmp5 = false;
            						}
HXDLIN( 259)						if (_hx_tmp5) {
HXLINE( 261)							firstframe = (firstFrame - frame->index);
            						}
HXLINE( 264)						 ::openfl::geom::ColorTransform coloreffect =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXLINE( 265)						coloreffect->_hx___copyFrom(colorEffect);
HXLINE( 266)						if (::hx::IsNotNull( frame->colorEffect )) {
HXLINE( 267)							coloreffect->concat(frame->colorEffect->_hx___create());
            						}
HXLINE( 268)						 ::flixel::math::FlxMatrix _hx_tmp7;
HXDLIN( 268)						if (toBitmap) {
HXLINE( 268)							_hx_tmp7 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            						}
            						else {
HXLINE( 268)							_hx_tmp7 = matrix;
            						}
HXDLIN( 268)						 ::Dynamic _hx_tmp8;
HXDLIN( 268)						if (toBitmap) {
HXLINE( 268)							_hx_tmp8 =  ::Dynamic(::hx::Anon_obj::Create(1)
            								->setFixed(0,HX_("instance",95,1f,e1,59),null()));
            						}
            						else {
HXLINE( 268)							_hx_tmp8 = filterInstance;
            						}
HXDLIN( 268)						::Array< ::Dynamic> _hx_tmp9;
HXDLIN( 268)						if (toBitmap) {
HXLINE( 268)							_hx_tmp9 = ::Array_obj< ::Dynamic>::__new(1)->init(0,layer->_filterCamera);
            						}
            						else {
HXLINE( 268)							_hx_tmp9 = cameras;
            						}
HXDLIN( 268)						this->parseElement(element,firstframe,_hx_tmp7,coloreffect,false,_hx_tmp8,_hx_tmp9);
HXLINE( 270)						bool _hx_tmp10;
HXDLIN( 270)						bool _hx_tmp11;
HXDLIN( 270)						if (toBitmap) {
HXLINE( 270)							_hx_tmp11 = ::hx::IsNotNull( element->symbol );
            						}
            						else {
HXLINE( 270)							_hx_tmp11 = false;
            						}
HXDLIN( 270)						if (_hx_tmp11) {
HXLINE( 270)							_hx_tmp10 = element->symbol->_layerDirty;
            						}
            						else {
HXLINE( 270)							_hx_tmp10 = false;
            						}
HXDLIN( 270)						if (_hx_tmp10) {
HXLINE( 271)							element->symbol->_layerDirty = false;
            						}
            					}
            				}
HXLINE( 274)				if (toBitmap) {
HXLINE( 276)					frame->_bitmapMatrix->identity();
HXLINE( 278)					this->renderFilter(layer->_filterCamera,frame->filters,frame->_filterFrame,frame->_bitmapMatrix,this->renderer);
HXLINE( 279)					frame->_renderDirty = false;
HXLINE( 281)					 ::flixel::math::FlxMatrix mat1 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 282)					mat1->concat(frame->_bitmapMatrix);
HXLINE( 283)					mat1->concat(instance->matrix);
HXLINE( 284)					mat1->concat(m);
HXLINE( 286)					this->drawLimb(frame->_filterFrame,mat1,null(),filterin,cameras);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC7(FlxAnimate_obj,parseElement,(void))

void FlxAnimate_obj::renderFilter( ::flixel::FlxCamera filterCamera,::Array< ::Dynamic> filters, ::flixel::graphics::frames::FlxFrame filter, ::flixel::math::FlxMatrix _cacheBitmapMatrix, ::flxanimate::display::FlxAnimateFilterRenderer renderer){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_291_renderFilter)
HXLINE( 293)		filterCamera->render();
HXLINE( 295)		 ::openfl::display::BitmapData gfx = renderer->graphicstoBitmapData(filterCamera->canvas->get_graphics());
HXLINE( 298)		if (::hx::IsNull( gfx )) {
HXLINE( 298)			return;
            		}
HXLINE( 301)		 ::openfl::geom::Rectangle bounds = gfx->rect->clone();
HXLINE( 303)		if (::hx::IsNull( bounds )) {
HXLINE( 303)			return;
            		}
HXLINE( 305)		 ::openfl::geom::Rectangle b =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 308)		filterCamera->canvas->_hx___getBounds(b,_cacheBitmapMatrix);
HXLINE( 310)		bool _hx_tmp;
HXDLIN( 310)		if (::hx::IsNotNull( filters )) {
HXLINE( 310)			_hx_tmp = (filters->length > 0);
            		}
            		else {
HXLINE( 310)			_hx_tmp = false;
            		}
HXDLIN( 310)		if (_hx_tmp) {
HXLINE( 311)			gfx = this->applyFilter(renderer,gfx,filters,bounds);
            		}
HXLINE( 314)		_cacheBitmapMatrix->translate(((b->x + bounds->x) - ((( (Float)(gfx->width) ) - bounds->width) * ((Float)0.5))),((b->y + bounds->y) - ((( (Float)(gfx->height) ) - bounds->height) * ((Float)0.5))));
HXLINE( 317)		filterCamera->clearDrawStack();
HXLINE( 318)		filterCamera->canvas->get_graphics()->clear();
HXLINE( 319)		filter->parent->bitmap->dispose();
HXLINE( 320)		filter->parent->set_bitmap(gfx);
HXLINE( 321)		{
HXLINE( 321)			 ::flixel::math::FlxRect _this = filter->frame;
HXDLIN( 321)			_this->width = ( (Float)(gfx->width) );
HXDLIN( 321)			_this->height = ( (Float)(gfx->height) );
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxAnimate_obj,renderFilter,(void))

 ::openfl::display::BitmapData FlxAnimate_obj::applyFilter( ::flxanimate::display::FlxAnimateFilterRenderer renderer, ::openfl::display::BitmapData image,::Array< ::Dynamic> filters, ::openfl::geom::Rectangle rect){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_325_applyFilter)
HXLINE( 328)		 ::openfl::geom::Rectangle extension = ::openfl::geom::Rectangle_obj::_hx___pool->get().StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 330)		{
HXLINE( 330)			int _g = 0;
HXDLIN( 330)			while((_g < filters->length)){
HXLINE( 330)				 ::openfl::filters::BitmapFilter filter = filters->__get(_g).StaticCast<  ::openfl::filters::BitmapFilter >();
HXDLIN( 330)				_g = (_g + 1);
HXLINE( 333)				extension->_hx___expand(( (Float)(-(filter->_hx___leftExtension)) ),( (Float)(-(filter->_hx___topExtension)) ),( (Float)((filter->_hx___leftExtension + filter->_hx___rightExtension)) ),( (Float)((filter->_hx___topExtension + filter->_hx___bottomExtension)) ));
            			}
            		}
HXLINE( 339)		 ::openfl::geom::Rectangle rect1 = rect;
HXDLIN( 339)		rect1->width = (rect1->width + extension->width);
HXLINE( 340)		 ::openfl::geom::Rectangle rect2 = rect;
HXDLIN( 340)		rect2->height = (rect2->height + extension->height);
HXLINE( 341)		 ::openfl::geom::Rectangle rect3 = rect;
HXDLIN( 341)		rect3->x = (rect3->x + extension->x);
HXLINE( 342)		 ::openfl::geom::Rectangle rect4 = rect;
HXDLIN( 342)		rect4->y = (rect4->y + extension->y);
HXLINE( 345)		::openfl::geom::Rectangle_obj::_hx___pool->release(extension);
HXLINE( 349)		return renderer->applyFilter(image,filters,rect);
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxAnimate_obj,applyFilter,return )

int FlxAnimate_obj::setButtonFrames(int frame){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_353_setButtonFrames)
HXLINE( 354)		bool badPress = false;
HXLINE( 355)		bool goodPress = false;
HXLINE( 357)		bool _hx_tmp;
HXDLIN( 357)		 ::flixel::input::mouse::FlxMouseButton _this = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 357)		bool _hx_tmp1;
HXDLIN( 357)		if ((_this->current != 1)) {
HXLINE( 357)			_hx_tmp1 = (_this->current == 2);
            		}
            		else {
HXLINE( 357)			_hx_tmp1 = true;
            		}
HXDLIN( 357)		if (_hx_tmp1) {
HXLINE( 357)			_hx_tmp = ::flixel::FlxG_obj::mouse->overlaps(::hx::ObjectPtr<OBJ_>(this),null());
            		}
            		else {
HXLINE( 357)			_hx_tmp = false;
            		}
HXDLIN( 357)		if (_hx_tmp) {
HXLINE( 358)			goodPress = true;
            		}
HXLINE( 359)		bool _hx_tmp2;
HXDLIN( 359)		bool _hx_tmp3;
HXDLIN( 359)		 ::flixel::input::mouse::FlxMouseButton _this1 = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 359)		bool _hx_tmp4;
HXDLIN( 359)		if ((_this1->current != 1)) {
HXLINE( 359)			_hx_tmp4 = (_this1->current == 2);
            		}
            		else {
HXLINE( 359)			_hx_tmp4 = true;
            		}
HXDLIN( 359)		if (_hx_tmp4) {
HXLINE( 359)			_hx_tmp3 = !(::flixel::FlxG_obj::mouse->overlaps(::hx::ObjectPtr<OBJ_>(this),null()));
            		}
            		else {
HXLINE( 359)			_hx_tmp3 = false;
            		}
HXDLIN( 359)		if (_hx_tmp3) {
HXLINE( 359)			_hx_tmp2 = !(goodPress);
            		}
            		else {
HXLINE( 359)			_hx_tmp2 = false;
            		}
HXDLIN( 359)		if (_hx_tmp2) {
HXLINE( 361)			badPress = true;
            		}
HXLINE( 363)		 ::flixel::input::mouse::FlxMouseButton _this2 = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 363)		bool _hx_tmp5;
HXDLIN( 363)		if ((_this2->current != 1)) {
HXLINE( 363)			_hx_tmp5 = (_this2->current == 2);
            		}
            		else {
HXLINE( 363)			_hx_tmp5 = true;
            		}
HXDLIN( 363)		if (!(_hx_tmp5)) {
HXLINE( 365)			badPress = false;
HXLINE( 366)			goodPress = false;
            		}
HXLINE( 368)		bool _hx_tmp6;
HXDLIN( 368)		if (::flixel::FlxG_obj::mouse->overlaps(::hx::ObjectPtr<OBJ_>(this),null())) {
HXLINE( 368)			_hx_tmp6 = !(badPress);
            		}
            		else {
HXLINE( 368)			_hx_tmp6 = false;
            		}
HXDLIN( 368)		if (_hx_tmp6) {
HXLINE( 371)			::Dynamic this1 = this->anim->buttonMap;
HXDLIN( 371)			 ::Dynamic event = ( ( ::haxe::ds::StringMap)(this1) )->get(this->anim->get_curSymbol()->name);
HXLINE( 372)			bool _hx_tmp7;
HXDLIN( 372)			if ((::flixel::FlxG_obj::mouse->_leftButton->current == 2)) {
HXLINE( 372)				_hx_tmp7 = !(this->pressed);
            			}
            			else {
HXLINE( 372)				_hx_tmp7 = false;
            			}
HXDLIN( 372)			if (_hx_tmp7) {
HXLINE( 374)				if (::hx::IsNotNull( event )) {
HXLINE( 375)					 ::Dynamic _this3;
HXDLIN( 375)					if (::hx::IsNotNull( event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic) )) {
HXLINE( 375)						_this3 =  ::Dynamic(event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic))->__Field(HX_("OnClick",89,42,ed,ab),::hx::paccDynamic);
            					}
            					else {
HXLINE( 375)						_this3 = null();
            					}
HXDLIN( 375)					 ::flxanimate::animate::ButtonEvent _this4 =  ::flxanimate::animate::ButtonEvent_obj::__alloc( HX_CTX ,_this3,( ( ::flixel::sound::FlxSound)(event->__Field(HX_("Sound",af,fc,f9,13),::hx::paccDynamic)) ));
HXDLIN( 375)					if (::hx::IsNotNull( _this4->callback )) {
HXLINE( 375)						_this4->callback();
            					}
HXDLIN( 375)					if (::hx::IsNotNull( _this4->sound )) {
HXLINE( 375)						_this4->sound->play(true,null(),null());
            					}
            				}
HXLINE( 376)				this->pressed = true;
            			}
HXLINE( 378)			 ::flixel::input::mouse::FlxMouseButton _this5 = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 378)			bool frame1;
HXDLIN( 378)			if ((_this5->current != 1)) {
HXLINE( 378)				frame1 = (_this5->current == 2);
            			}
            			else {
HXLINE( 378)				frame1 = true;
            			}
HXDLIN( 378)			if (frame1) {
HXLINE( 378)				frame = 2;
            			}
            			else {
HXLINE( 378)				frame = 1;
            			}
HXLINE( 380)			bool _hx_tmp8;
HXDLIN( 380)			if ((::flixel::FlxG_obj::mouse->_leftButton->current == -1)) {
HXLINE( 380)				_hx_tmp8 = this->pressed;
            			}
            			else {
HXLINE( 380)				_hx_tmp8 = false;
            			}
HXDLIN( 380)			if (_hx_tmp8) {
HXLINE( 382)				if (::hx::IsNotNull( event )) {
HXLINE( 383)					 ::Dynamic _this6;
HXDLIN( 383)					if (::hx::IsNotNull( event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic) )) {
HXLINE( 383)						_this6 =  ::Dynamic(event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic))->__Field(HX_("OnRelease",48,1e,6b,d2),::hx::paccDynamic);
            					}
            					else {
HXLINE( 383)						_this6 = null();
            					}
HXDLIN( 383)					 ::flxanimate::animate::ButtonEvent _this7 =  ::flxanimate::animate::ButtonEvent_obj::__alloc( HX_CTX ,_this6,( ( ::flixel::sound::FlxSound)(event->__Field(HX_("Sound",af,fc,f9,13),::hx::paccDynamic)) ));
HXDLIN( 383)					if (::hx::IsNotNull( _this7->callback )) {
HXLINE( 383)						_this7->callback();
            					}
HXDLIN( 383)					if (::hx::IsNotNull( _this7->sound )) {
HXLINE( 383)						_this7->sound->play(true,null(),null());
            					}
            				}
HXLINE( 384)				this->pressed = false;
            			}
            		}
            		else {
HXLINE( 389)			frame = 0;
            		}
HXLINE( 394)		return frame;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,setButtonFrames,return )

void FlxAnimate_obj::drawLimb( ::flixel::graphics::frames::FlxFrame limb, ::flixel::math::FlxMatrix _matrix, ::openfl::geom::ColorTransform colorTransform,::hx::Null< bool >  __o_filterin,::Array< ::Dynamic> cameras){
            		bool filterin = __o_filterin.Default(false);
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_398_drawLimb)
HXLINE( 399)		bool _hx_tmp;
HXDLIN( 399)		bool _hx_tmp1;
HXDLIN( 399)		bool _hx_tmp2;
HXDLIN( 399)		bool _hx_tmp3;
HXDLIN( 399)		if (::hx::IsNotNull( cameras )) {
HXLINE( 399)			_hx_tmp3 = (this->alpha == 0);
            		}
            		else {
HXLINE( 399)			_hx_tmp3 = true;
            		}
HXDLIN( 399)		if (!(_hx_tmp3)) {
HXLINE( 399)			if (::hx::IsNotNull( colorTransform )) {
HXLINE( 399)				if ((colorTransform->alphaMultiplier != 0)) {
HXLINE( 399)					_hx_tmp2 = (colorTransform->alphaOffset == -255);
            				}
            				else {
HXLINE( 399)					_hx_tmp2 = true;
            				}
            			}
            			else {
HXLINE( 399)				_hx_tmp2 = false;
            			}
            		}
            		else {
HXLINE( 399)			_hx_tmp2 = true;
            		}
HXDLIN( 399)		if (!(_hx_tmp2)) {
HXLINE( 399)			_hx_tmp1 = ::hx::IsNull( limb );
            		}
            		else {
HXLINE( 399)			_hx_tmp1 = true;
            		}
HXDLIN( 399)		if (!(_hx_tmp1)) {
HXLINE( 399)			_hx_tmp = (limb->type == 2);
            		}
            		else {
HXLINE( 399)			_hx_tmp = true;
            		}
HXDLIN( 399)		if (_hx_tmp) {
HXLINE( 400)			return;
            		}
HXLINE( 402)		{
HXLINE( 402)			int _g = 0;
HXDLIN( 402)			while((_g < cameras->length)){
HXLINE( 402)				 ::flixel::FlxCamera camera = cameras->__get(_g).StaticCast<  ::flixel::FlxCamera >();
HXDLIN( 402)				_g = (_g + 1);
HXLINE( 404)				limb->prepareMatrix(this->_mat,null(),null(),null());
HXLINE( 405)				 ::flixel::math::FlxMatrix matrix = this->_mat;
HXLINE( 406)				matrix->concat(_matrix);
HXLINE( 407)				bool _hx_tmp4;
HXDLIN( 407)				if (camera->visible) {
HXLINE( 407)					_hx_tmp4 = !(camera->exists);
            				}
            				else {
HXLINE( 407)					_hx_tmp4 = true;
            				}
HXDLIN( 407)				if (_hx_tmp4) {
HXLINE( 408)					return;
            				}
HXLINE( 410)				if (!(filterin)) {
HXLINE( 412)					{
HXLINE( 412)						 ::flixel::math::FlxBasePoint this1 = this->getScreenPosition(this->_point,camera);
HXDLIN( 412)						 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN( 412)						{
HXLINE( 412)							Float y = point->y;
HXDLIN( 412)							this1->set_x((this1->x - point->x));
HXDLIN( 412)							this1->set_y((this1->y - y));
            						}
HXDLIN( 412)						if (point->_weak) {
HXLINE( 412)							point->put();
            						}
            					}
HXLINE( 413)					if ((::Array_obj< ::Dynamic>::__new(2)->init(0,this->_pivot)->init(1,this->_indicator)->indexOf(limb,null()) == -1)) {
HXLINE( 415)						matrix->translate(-(this->origin->x),-(this->origin->y));
HXLINE( 417)						matrix->scale(this->scale->x,this->scale->y);
HXLINE( 419)						if ((this->bakedRotationAngle <= 0)) {
HXLINE( 421)							if (this->_angleChanged) {
HXLINE( 421)								Float radians = (this->angle * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN( 421)								this->_sinAngle = ::Math_obj::sin(radians);
HXDLIN( 421)								this->_cosAngle = ::Math_obj::cos(radians);
HXDLIN( 421)								this->_angleChanged = false;
            							}
HXLINE( 423)							if ((this->angle != 0)) {
HXLINE( 424)								Float cos = this->_cosAngle;
HXDLIN( 424)								Float sin = this->_sinAngle;
HXDLIN( 424)								Float a1 = ((matrix->a * cos) - (matrix->b * sin));
HXDLIN( 424)								matrix->b = ((matrix->a * sin) + (matrix->b * cos));
HXDLIN( 424)								matrix->a = a1;
HXDLIN( 424)								Float c1 = ((matrix->c * cos) - (matrix->d * sin));
HXDLIN( 424)								matrix->d = ((matrix->c * sin) + (matrix->d * cos));
HXDLIN( 424)								matrix->c = c1;
HXDLIN( 424)								Float tx1 = ((matrix->tx * cos) - (matrix->ty * sin));
HXDLIN( 424)								matrix->ty = ((matrix->tx * sin) + (matrix->ty * cos));
HXDLIN( 424)								matrix->tx = tx1;
            							}
            						}
HXLINE( 427)						{
HXLINE( 427)							 ::flixel::math::FlxBasePoint this2 = this->_point;
HXDLIN( 427)							 ::flixel::math::FlxBasePoint point1 = this->origin;
HXDLIN( 427)							{
HXLINE( 427)								Float y1 = point1->y;
HXDLIN( 427)								this2->set_x((this2->x + point1->x));
HXDLIN( 427)								this2->set_y((this2->y + y1));
            							}
HXDLIN( 427)							if (point1->_weak) {
HXLINE( 427)								point1->put();
            							}
            						}
            					}
            					else {
HXLINE( 431)						matrix->scale(((Float)0.7),((Float)0.7));
HXLINE( 433)						 ::flixel::math::FlxMatrix matrix1 = matrix;
HXDLIN( 433)						matrix1->a = (matrix1->a / camera->zoom);
HXLINE( 434)						 ::flixel::math::FlxMatrix matrix2 = matrix;
HXDLIN( 434)						matrix2->d = (matrix2->d / camera->zoom);
HXLINE( 435)						 ::flixel::math::FlxMatrix matrix3 = matrix;
HXDLIN( 435)						matrix3->tx = (matrix3->tx / camera->zoom);
HXLINE( 436)						 ::flixel::math::FlxMatrix matrix4 = matrix;
HXDLIN( 436)						matrix4->ty = (matrix4->ty / camera->zoom);
            					}
HXLINE( 442)					if (this->isPixelPerfectRender(camera)) {
HXLINE( 444)						 ::flixel::math::FlxBasePoint this3 = this->_point;
HXDLIN( 444)						this3->set_x(( (Float)(::Math_obj::floor(this3->x)) ));
HXDLIN( 444)						this3->set_y(( (Float)(::Math_obj::floor(this3->y)) ));
            					}
HXLINE( 447)					matrix->translate(this->_point->x,this->_point->y);
HXLINE( 449)					if (!(this->limbOnScreen(limb,matrix,camera))) {
HXLINE( 450)						return;
            					}
            				}
HXLINE( 452)				camera->drawPixels(limb,null(),matrix,colorTransform,this->blend,this->antialiasing,null());
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxAnimate_obj,drawLimb,(void))

bool FlxAnimate_obj::limbOnScreen( ::flixel::graphics::frames::FlxFrame limb, ::flixel::math::FlxMatrix m, ::flixel::FlxCamera Camera){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_465_limbOnScreen)
HXLINE( 466)		if (::hx::IsNull( Camera )) {
HXLINE( 467)			Camera = ::flixel::FlxG_obj::camera;
            		}
HXLINE( 469)		{
HXLINE( 469)			 ::flixel::math::FlxRect _this = limb->frame;
HXDLIN( 469)			 ::openfl::geom::Rectangle FlashRect = this->rect;
HXDLIN( 469)			if (::hx::IsNull( FlashRect )) {
HXLINE( 469)				FlashRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 469)			FlashRect->x = _this->x;
HXDLIN( 469)			FlashRect->y = _this->y;
HXDLIN( 469)			FlashRect->width = _this->width;
HXDLIN( 469)			FlashRect->height = _this->height;
            		}
HXLINE( 471)		this->rect->x = ( (Float)(0) );
HXLINE( 472)		this->rect->y = ( (Float)(0) );
HXLINE( 474)		this->rect->_hx___transform(this->rect,m);
HXLINE( 476)		{
HXLINE( 476)			 ::flixel::math::FlxBasePoint this1 = this->_point;
HXDLIN( 476)			 ::openfl::geom::Point p = this->rect->get_topLeft();
HXDLIN( 476)			this1->set(p->x,p->y);
            		}
HXLINE( 478)		if (::hx::IsInstanceNotEq( limb,this->_pivot )) {
HXLINE( 479)			this->_flashRect = this->_flashRect->_hx_union(this->rect);
            		}
HXLINE( 481)		 ::flixel::math::FlxBasePoint point = this->_point;
HXDLIN( 481)		bool contained;
HXDLIN( 481)		bool contained1;
HXDLIN( 481)		bool contained2;
HXDLIN( 481)		if (((point->x + this->rect->width) > Camera->viewMarginX)) {
HXLINE( 481)			contained2 = (point->x < (( (Float)(Camera->width) ) - Camera->viewMarginX));
            		}
            		else {
HXLINE( 481)			contained2 = false;
            		}
HXDLIN( 481)		if (contained2) {
HXLINE( 481)			contained1 = ((point->y + this->rect->height) > Camera->viewMarginY);
            		}
            		else {
HXLINE( 481)			contained1 = false;
            		}
HXDLIN( 481)		if (contained1) {
HXLINE( 481)			contained = (point->y < (( (Float)(Camera->height) ) - Camera->viewMarginY));
            		}
            		else {
HXLINE( 481)			contained = false;
            		}
HXDLIN( 481)		if (point->_weak) {
HXLINE( 481)			point->put();
            		}
HXDLIN( 481)		return contained;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxAnimate_obj,limbOnScreen,return )

void FlxAnimate_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_485_destroy)
HXLINE( 486)		if (::hx::IsNotNull( this->anim )) {
HXLINE( 487)			this->anim->destroy();
            		}
HXLINE( 488)		this->anim = null();
HXLINE( 494)		this->super::destroy();
            	}


void FlxAnimate_obj::updateAnimation(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_499_updateAnimation)
HXDLIN( 499)		this->anim->update(elapsed);
            	}


void FlxAnimate_obj::setButtonPack(::String button, ::Dynamic callbacks, ::flixel::sound::FlxSound sound){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_505_setButtonPack)
HXDLIN( 505)		this->anim->buttonMap->set(button, ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("Sound",af,fc,f9,13),sound)
            			->setFixed(1,HX_("Callbacks",ee,d2,92,48),callbacks)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxAnimate_obj,setButtonPack,(void))

void FlxAnimate_obj::setTheSettings( ::Dynamic Settings){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_512_setTheSettings)
HXLINE( 513)		this->set_antialiasing(( (bool)(Settings->__Field(HX_("Antialiasing",14,63,c5,10),::hx::paccDynamic)) ));
HXLINE( 514)		if (::hx::IsNotNull( Settings->__Field(HX_("ButtonSettings",15,71,23,aa),::hx::paccDynamic) )) {
HXLINE( 516)			this->anim->buttonMap = ( ( ::haxe::ds::StringMap)(Settings->__Field(HX_("ButtonSettings",15,71,23,aa),::hx::paccDynamic)) );
HXLINE( 517)			if (::hx::IsPointerNotEq( this->anim->get_symbolType(),::flxanimate::data::SymbolT_obj::Button_dyn() )) {
HXLINE( 518)				this->anim->set_symbolType(::flxanimate::data::SymbolT_obj::Button_dyn());
            			}
            		}
HXLINE( 520)		if (::hx::IsNotNull( Settings->__Field(HX_("Reversed",22,81,67,5b),::hx::paccDynamic) )) {
HXLINE( 521)			this->anim->set_reversed(( (bool)(Settings->__Field(HX_("Reversed",22,81,67,5b),::hx::paccDynamic)) ));
            		}
HXLINE( 522)		if (::hx::IsNotNull( Settings->__Field(HX_("FrameRate",8d,f1,f7,da),::hx::paccDynamic) )) {
HXLINE( 523)			Float _hx_tmp;
HXDLIN( 523)			if (::hx::IsGreater( Settings->__Field(HX_("FrameRate",8d,f1,f7,da),::hx::paccDynamic),0 )) {
HXLINE( 523)				_hx_tmp = this->anim->metadata->frameRate;
            			}
            			else {
HXLINE( 523)				_hx_tmp = ( (Float)(Settings->__Field(HX_("FrameRate",8d,f1,f7,da),::hx::paccDynamic)) );
            			}
HXDLIN( 523)			this->anim->set_framerate(_hx_tmp);
            		}
HXLINE( 524)		if (::hx::IsNotNull( Settings->__Field(HX_("OnComplete",18,d9,2f,54),::hx::paccDynamic) )) {
HXLINE( 525)			this->anim->onComplete = Settings->__Field(HX_("OnComplete",18,d9,2f,54),::hx::paccDynamic);
            		}
HXLINE( 526)		if (::hx::IsNotNull( Settings->__Field(HX_("ShowPivot",65,90,d9,92),::hx::paccDynamic) )) {
HXLINE( 527)			this->showPivot = ( (bool)(Settings->__Field(HX_("ShowPivot",65,90,d9,92),::hx::paccDynamic)) );
            		}
HXLINE( 528)		if (::hx::IsNotNull( Settings->__Field(HX_("Antialiasing",14,63,c5,10),::hx::paccDynamic) )) {
HXLINE( 529)			this->set_antialiasing(( (bool)(Settings->__Field(HX_("Antialiasing",14,63,c5,10),::hx::paccDynamic)) ));
            		}
HXLINE( 530)		if (::hx::IsNotNull( Settings->__Field(HX_("ScrollFactor",dc,38,e2,03),::hx::paccDynamic) )) {
HXLINE( 531)			this->scrollFactor = ( ( ::flixel::math::FlxBasePoint)(Settings->__Field(HX_("ScrollFactor",dc,38,e2,03),::hx::paccDynamic)) );
            		}
HXLINE( 532)		if (::hx::IsNotNull( Settings->__Field(HX_("Offset",b3,0b,d4,94),::hx::paccDynamic) )) {
HXLINE( 533)			this->offset = ( ( ::flixel::math::FlxBasePoint)(Settings->__Field(HX_("Offset",b3,0b,d4,94),::hx::paccDynamic)) );
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,setTheSettings,(void))

 ::Dynamic FlxAnimate_obj::atlasSetting(::String Path){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_538_atlasSetting)
HXLINE( 539)		 ::Dynamic jsontxt = null();
HXLINE( 540)		if ((::haxe::io::Path_obj::extension(Path) == HX_("zip",e1,ee,5c,00))) {
HXLINE( 543)			 ::haxe::ds::List thing = ::flxanimate::zip::Zip_obj::readZip(::sys::io::File_obj::getBytes(Path));
HXLINE( 548)			{
HXLINE( 548)				 ::haxe::ds::_List::ListNode _g_head = ::flxanimate::zip::Zip_obj::unzip(thing)->h;
HXDLIN( 548)				while(::hx::IsNotNull( _g_head )){
HXLINE( 548)					 ::Dynamic val = _g_head->item;
HXDLIN( 548)					_g_head = _g_head->next;
HXDLIN( 548)					 ::Dynamic list = val;
HXLINE( 550)					if ((( (::String)(list->__Field(HX_("fileName",e7,5a,43,62),::hx::paccDynamic)) ).indexOf(HX_("Animation.json",f2,a7,22,ea),null()) != -1)) {
HXLINE( 552)						jsontxt =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,( ( ::haxe::io::Bytes)(list->__Field(HX_("data",2a,56,63,42),::hx::paccDynamic)) )->toString())->doParse();
HXLINE( 553)						thing->remove(list);
HXLINE( 554)						continue;
            					}
            				}
            			}
HXLINE( 558)			::flxanimate::frames::FlxAnimateFrames_obj::zip = thing;
            		}
            		else {
HXLINE( 563)			jsontxt =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(((HX_("",00,00,00,00) + Path) + HX_("/Animation.json",61,fc,54,44))))->doParse();
            		}
HXLINE( 569)		return jsontxt;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,atlasSetting,return )

void FlxAnimate_obj::loadAtlasEx( ::Dynamic img,::String pathOrStr, ::Dynamic myJson){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_573_loadAtlasEx)
HXLINE( 574)		 ::Dynamic animJson = null();
HXLINE( 575)		if (::Std_obj::isOfType(myJson,::hx::ClassOf< ::String >())) {
HXLINE( 577)			::String trimmed = ::StringTools_obj::trim(pathOrStr);
HXLINE( 578)			trimmed = trimmed.substr((trimmed.length - 5),null()).toLowerCase();
HXLINE( 580)			if ((trimmed == HX_(".json",56,f1,d6,c2))) {
HXLINE( 580)				myJson = ::sys::io::File_obj::getContent(( (::String)(myJson) ));
            			}
HXLINE( 581)			animJson =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,this->_removeBOM(( (::String)(myJson) )))->doParse();
            		}
            		else {
HXLINE( 583)			animJson = myJson;
            		}
HXLINE( 585)		 ::Dynamic isXml = null();
HXLINE( 586)		 ::Dynamic myData = pathOrStr;
HXLINE( 588)		::String trimmed1 = ::StringTools_obj::trim(pathOrStr);
HXLINE( 589)		trimmed1 = trimmed1.substr((trimmed1.length - 5),null()).toLowerCase();
HXLINE( 591)		if ((trimmed1 == HX_(".json",56,f1,d6,c2))) {
HXLINE( 593)			myData = ::sys::io::File_obj::getContent(pathOrStr);
HXLINE( 594)			isXml = false;
            		}
            		else {
HXLINE( 596)			if ((trimmed1.substr(1,null()) == HX_(".xml",69,3e,c3,1e))) {
HXLINE( 598)				myData = ::sys::io::File_obj::getContent(pathOrStr);
HXLINE( 599)				isXml = true;
            			}
            		}
HXLINE( 601)		myData = this->_removeBOM(( (::String)(myData) ));
HXLINE( 604)		if (::hx::IsNull( isXml )) {
HXLINE( 611)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 613)				myData =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,( (::String)(myData) ))->doParse();
HXLINE( 614)				isXml = false;
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE( 619)					myData = ::Xml_obj::parse(( (::String)(myData) ));
HXLINE( 620)					isXml = true;
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
            		else {
HXLINE( 604)			if (( (bool)(isXml) )) {
HXLINE( 607)				myData = ::Xml_obj::parse(( (::String)(myData) ));
            			}
            			else {
HXLINE( 609)				myData =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,( (::String)(myData) ))->doParse();
            			}
            		}
HXLINE( 625)		this->anim->_loadAtlas(animJson);
HXLINE( 626)		if (!(( (bool)(isXml) ))) {
HXLINE( 626)			this->set_frames(::flxanimate::frames::FlxAnimateFrames_obj::fromAnimateAtlas(myData,img));
            		}
            		else {
HXLINE( 627)			this->set_frames(::flxanimate::frames::FlxAnimateFrames_obj::fromSparrow(myData,img));
            		}
HXLINE( 628)		this->origin = this->anim->curInstance->symbol->transformationPoint;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxAnimate_obj,loadAtlasEx,(void))

::String FlxAnimate_obj::_removeBOM(::String str){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_632__removeBOM)
HXLINE( 633)		if (::hx::IsEq( str.charCodeAt(0),65279 )) {
HXLINE( 633)			str = str.substr(1,null());
            		}
HXLINE( 634)		return str;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,_removeBOM,return )


::hx::ObjectPtr< FlxAnimate_obj > FlxAnimate_obj::__new(::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y,::String Path, ::Dynamic Settings) {
	::hx::ObjectPtr< FlxAnimate_obj > __this = new FlxAnimate_obj();
	__this->__construct(__o_X,__o_Y,Path,Settings);
	return __this;
}

::hx::ObjectPtr< FlxAnimate_obj > FlxAnimate_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y,::String Path, ::Dynamic Settings) {
	FlxAnimate_obj *__this = (FlxAnimate_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxAnimate_obj), true, "flxanimate.FlxAnimate"));
	*(void **)__this = FlxAnimate_obj::_hx_vtable;
	__this->__construct(__o_X,__o_Y,Path,Settings);
	return __this;
}

FlxAnimate_obj::FlxAnimate_obj()
{
}

void FlxAnimate_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxAnimate);
	HX_MARK_MEMBER_NAME(anim,"anim");
	HX_MARK_MEMBER_NAME(rect,"rect");
	HX_MARK_MEMBER_NAME(_symbols,"_symbols");
	HX_MARK_MEMBER_NAME(showPivot,"showPivot");
	HX_MARK_MEMBER_NAME(_pivot,"_pivot");
	HX_MARK_MEMBER_NAME(_indicator,"_indicator");
	HX_MARK_MEMBER_NAME(renderer,"renderer");
	HX_MARK_MEMBER_NAME(filterCamera,"filterCamera");
	HX_MARK_MEMBER_NAME(_sprite,"_sprite");
	HX_MARK_MEMBER_NAME(pressed,"pressed");
	HX_MARK_MEMBER_NAME(_mat,"_mat");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxAnimate_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(anim,"anim");
	HX_VISIT_MEMBER_NAME(rect,"rect");
	HX_VISIT_MEMBER_NAME(_symbols,"_symbols");
	HX_VISIT_MEMBER_NAME(showPivot,"showPivot");
	HX_VISIT_MEMBER_NAME(_pivot,"_pivot");
	HX_VISIT_MEMBER_NAME(_indicator,"_indicator");
	HX_VISIT_MEMBER_NAME(renderer,"renderer");
	HX_VISIT_MEMBER_NAME(filterCamera,"filterCamera");
	HX_VISIT_MEMBER_NAME(_sprite,"_sprite");
	HX_VISIT_MEMBER_NAME(pressed,"pressed");
	HX_VISIT_MEMBER_NAME(_mat,"_mat");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxAnimate_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"anim") ) { return ::hx::Val( anim ); }
		if (HX_FIELD_EQ(inName,"rect") ) { return ::hx::Val( rect ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		if (HX_FIELD_EQ(inName,"_mat") ) { return ::hx::Val( _mat ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_pivot") ) { return ::hx::Val( _pivot ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_sprite") ) { return ::hx::Val( _sprite ); }
		if (HX_FIELD_EQ(inName,"pressed") ) { return ::hx::Val( pressed ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_symbols") ) { return ::hx::Val( _symbols ); }
		if (HX_FIELD_EQ(inName,"renderer") ) { return ::hx::Val( renderer ); }
		if (HX_FIELD_EQ(inName,"drawLimb") ) { return ::hx::Val( drawLimb_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"showPivot") ) { return ::hx::Val( showPivot ); }
		if (HX_FIELD_EQ(inName,"loadAtlas") ) { return ::hx::Val( loadAtlas_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_indicator") ) { return ::hx::Val( _indicator ); }
		if (HX_FIELD_EQ(inName,"_removeBOM") ) { return ::hx::Val( _removeBOM_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"applyFilter") ) { return ::hx::Val( applyFilter_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadAtlasEx") ) { return ::hx::Val( loadAtlasEx_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"filterCamera") ) { return ::hx::Val( filterCamera ); }
		if (HX_FIELD_EQ(inName,"parseElement") ) { return ::hx::Val( parseElement_dyn() ); }
		if (HX_FIELD_EQ(inName,"renderFilter") ) { return ::hx::Val( renderFilter_dyn() ); }
		if (HX_FIELD_EQ(inName,"limbOnScreen") ) { return ::hx::Val( limbOnScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"atlasSetting") ) { return ::hx::Val( atlasSetting_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"setButtonPack") ) { return ::hx::Val( setButtonPack_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setTheSettings") ) { return ::hx::Val( setTheSettings_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"setButtonFrames") ) { return ::hx::Val( setButtonFrames_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateAnimation") ) { return ::hx::Val( updateAnimation_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FlxAnimate_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"anim") ) { anim=inValue.Cast<  ::flxanimate::animate::FlxAnim >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rect") ) { rect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_mat") ) { _mat=inValue.Cast<  ::flixel::math::FlxMatrix >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_pivot") ) { _pivot=inValue.Cast<  ::flixel::graphics::frames::FlxFrame >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_sprite") ) { _sprite=inValue.Cast<  ::openfl::display::Sprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pressed") ) { pressed=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_symbols") ) { _symbols=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"renderer") ) { renderer=inValue.Cast<  ::flxanimate::display::FlxAnimateFilterRenderer >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"showPivot") ) { showPivot=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_indicator") ) { _indicator=inValue.Cast<  ::flixel::graphics::frames::FlxFrame >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"filterCamera") ) { filterCamera=inValue.Cast<  ::flixel::FlxCamera >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxAnimate_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("anim",11,86,71,40));
	outFields->push(HX_("rect",24,4d,a7,4b));
	outFields->push(HX_("_symbols",9c,17,d4,4c));
	outFields->push(HX_("showPivot",85,b0,06,f1));
	outFields->push(HX_("_pivot",03,92,89,be));
	outFields->push(HX_("_indicator",90,63,50,ef));
	outFields->push(HX_("renderer",43,c5,db,b2));
	outFields->push(HX_("filterCamera",7d,74,e4,c3));
	outFields->push(HX_("_sprite",a4,ed,0c,32));
	outFields->push(HX_("pressed",a2,d2,e6,39));
	outFields->push(HX_("_mat",a1,4f,1e,3f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxAnimate_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flxanimate::animate::FlxAnim */ ,(int)offsetof(FlxAnimate_obj,anim),HX_("anim",11,86,71,40)},
	{::hx::fsObject /*  ::openfl::geom::Rectangle */ ,(int)offsetof(FlxAnimate_obj,rect),HX_("rect",24,4d,a7,4b)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxAnimate_obj,_symbols),HX_("_symbols",9c,17,d4,4c)},
	{::hx::fsBool,(int)offsetof(FlxAnimate_obj,showPivot),HX_("showPivot",85,b0,06,f1)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFrame */ ,(int)offsetof(FlxAnimate_obj,_pivot),HX_("_pivot",03,92,89,be)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFrame */ ,(int)offsetof(FlxAnimate_obj,_indicator),HX_("_indicator",90,63,50,ef)},
	{::hx::fsObject /*  ::flxanimate::display::FlxAnimateFilterRenderer */ ,(int)offsetof(FlxAnimate_obj,renderer),HX_("renderer",43,c5,db,b2)},
	{::hx::fsObject /*  ::flixel::FlxCamera */ ,(int)offsetof(FlxAnimate_obj,filterCamera),HX_("filterCamera",7d,74,e4,c3)},
	{::hx::fsObject /*  ::openfl::display::Sprite */ ,(int)offsetof(FlxAnimate_obj,_sprite),HX_("_sprite",a4,ed,0c,32)},
	{::hx::fsBool,(int)offsetof(FlxAnimate_obj,pressed),HX_("pressed",a2,d2,e6,39)},
	{::hx::fsObject /*  ::flixel::math::FlxMatrix */ ,(int)offsetof(FlxAnimate_obj,_mat),HX_("_mat",a1,4f,1e,3f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlxAnimate_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxAnimate_obj_sMemberFields[] = {
	HX_("anim",11,86,71,40),
	HX_("rect",24,4d,a7,4b),
	HX_("_symbols",9c,17,d4,4c),
	HX_("showPivot",85,b0,06,f1),
	HX_("_pivot",03,92,89,be),
	HX_("_indicator",90,63,50,ef),
	HX_("renderer",43,c5,db,b2),
	HX_("filterCamera",7d,74,e4,c3),
	HX_("_sprite",a4,ed,0c,32),
	HX_("loadAtlas",45,99,14,42),
	HX_("draw",04,2c,70,42),
	HX_("parseElement",c9,02,2f,60),
	HX_("renderFilter",ae,23,8b,f4),
	HX_("applyFilter",c6,df,2f,c1),
	HX_("pressed",a2,d2,e6,39),
	HX_("setButtonFrames",fa,59,f9,72),
	HX_("_mat",a1,4f,1e,3f),
	HX_("drawLimb",36,c1,1c,5c),
	HX_("limbOnScreen",1d,67,d7,38),
	HX_("destroy",fa,2c,86,24),
	HX_("updateAnimation",bb,bf,bf,9a),
	HX_("setButtonPack",2d,84,c0,55),
	HX_("setTheSettings",f2,2d,f5,c8),
	HX_("atlasSetting",85,cb,d6,01),
	HX_("loadAtlasEx",18,71,61,63),
	HX_("_removeBOM",dd,3b,88,26),
	::String(null()) };

::hx::Class FlxAnimate_obj::__mClass;

void FlxAnimate_obj::__register()
{
	FlxAnimate_obj _hx_dummy;
	FlxAnimate_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flxanimate.FlxAnimate",0e,fa,42,da);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxAnimate_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxAnimate_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxAnimate_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxAnimate_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flxanimate
